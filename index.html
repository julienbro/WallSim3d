<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Mur Simulateur 3D (Vue Initiale + Sélecteur Fractions)</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.2/css/all.min.css" integrity="sha512-SnH5WK+bZxgPHs44uWIX+LLJAJ9/2PkPKZ5QiAj6Ta86w+fsb2TkcmfRyVX3pBnMFcV7oQPJkl9QevSCWr3W6A==" crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        /* Styles CSS (ajout sélecteur taille) */
        html, body { overscroll-behavior: none; margin: 0; height: 100%; width: 100%; overflow: hidden; font-family: 'Inter', sans-serif; }
        body { display: flex; flex-direction: column; background-color: #f0f0f0; }
        #toolbar { background-color: #e9ecef; padding: 8px 10px; border-bottom: 1px solid #dee2e6; display: flex; gap: 8px; align-items: center; box-shadow: 0 2px 4px rgba(0,0,0,0.1); flex-wrap: wrap; flex-shrink: 0; z-index: 10; }
        #toolbar button, #toolbar select, #toolbar input[type="number"], #toolbar input[type="text"] { padding: 8px 10px; border: 1px solid #ced4da; background-color: #ffffff; color: #495057; cursor: pointer; border-radius: 5px; font-size: 14px; transition: background-color 0.2s ease, border-color 0.2s ease; height: 38px; box-sizing: border-box; flex-shrink: 0; display: inline-flex; align-items: center; justify-content: center; gap: 6px; white-space: nowrap; }
        #toolbar button i.fa-fw, #context-menu button i.fa-fw { width: 1.25em; text-align: center; }
        .view-button { min-width: 38px; font-weight: bold; padding: 8px; }
        #toolbar button.active { background-color: #007bff; color: white; border-color: #0056b3; font-weight: bold; }
        #toolbar button.disabled, #toolbar button:disabled { background-color: #e9ecef; border-color: #ced4da; color: #adb5bd; cursor: not-allowed; }
        #toolbar button:hover:not(.active):not(:disabled) { background-color: #f1f3f5; border-color: #adb5bd; }
        #toolbar label { font-size: 14px; margin-left: 4px; margin-right: 2px; color: #495057; white-space: nowrap; align-self: center; }
        #toolbar input[type="number"] { width: 65px; cursor: text; }
        #toolbar input[type="text"] { width: 100px; cursor: text; }
        #viewport-container { flex-grow: 1; position: relative; overflow: hidden; background-color: #cccccc; -webkit-tap-highlight-color: transparent; cursor: default; }
        #viewport-container.crosshair-cursor { cursor: crosshair; }
        #viewport-container.pointer-cursor { cursor: pointer; }
        canvas { display: block; }
        .info-text { font-size: 12px; color: #6c757d; padding: 0 10px; flex-basis: 100%; text-align: center; margin-top: 5px; order: 99; }
        #element-select, #assise-select { min-width: 150px; flex-grow: 1; max-width: 200px; } /* Slightly reduced max-width */
        #size-select { min-width: 120px; } /* Width for size select */
        .toolbar-group { display: flex; gap: 4px; align-items: center; border-left: 1px solid #ccc; padding-left: 8px; margin-left: 8px; }
        #element-size-group { display: flex; gap: 4px; align-items: center; } /* Group for element and size */
        #size-select-group { display: none; /* Hidden by default */ margin-left: 4px; }
        #custom-element-group { display: none; gap: 6px; align-items: center; padding: 5px; background-color: #f8f9fa; border: 1px dashed #adb5bd; border-radius: 5px; margin-left: 10px; flex-wrap: wrap; }
        #custom-element-group label { margin-left: 0; margin-right: 2px; } #custom-element-group input { flex-grow: 0; }
        #watermark { position: absolute; bottom: 10px; left: 10px; font-size: 10px; color: rgba(0, 0, 0, 0.4); background-color: rgba(255, 255, 255, 0.3); padding: 2px 5px; border-radius: 3px; pointer-events: none; z-index: 5; }
        #placement-controls { position: absolute; bottom: 45px; right: 20px; display: none; flex-direction: column; align-items: center; gap: 10px; background-color: rgba(233, 236, 239, 0.8); padding: 15px; border-radius: 10px; z-index: 20; touch-action: none; }
        #dpad-container { display: flex; align-items: center; gap: 15px; }
        #dpad { display: grid; grid-template-columns: 40px 40px 40px; grid-template-rows: 40px 40px 40px; gap: 5px; justify-items: center; align-items: center; }
        #dpad button, #placement-rotation button, #placement-vertical button { width: 40px; height: 40px; font-size: 18px; line-height: 40px; text-align: center; padding: 0; border: 1px solid #adb5bd; background-color: #f8f9fa; border-radius: 5px; cursor: pointer; user-select: none; -webkit-tap-highlight-color: transparent; }
        #dpad button:hover, #placement-rotation button:hover, #placement-vertical button:hover { background-color: #e2e6ea; }
        #dpad button:active, #placement-rotation button:active, #placement-vertical button:active { background-color: #ced4da; }
        #dpad-up { grid-column: 2; grid-row: 1; } #dpad-left { grid-column: 1; grid-row: 2; } #dpad-right { grid-column: 3; grid-row: 2; } #dpad-down { grid-column: 2; grid-row: 3; }
        #placement-rotation, #placement-vertical { display: flex; flex-direction: column; gap: 5px; }
        #placement-actions { display: flex; gap: 10px; margin-top: 10px; }
        #placement-actions button { width: 50px; height: 50px; font-size: 22px; border-radius: 50%; border: none; color: white; cursor: pointer; display: flex; align-items: center; justify-content: center; }
        #btn-place-element, #btn-confirm-move { background-color: #28a745; } #btn-cancel-placement, #btn-cancel-move { background-color: #dc3545; }
        #btn-place-element:hover, #btn-confirm-move:hover { background-color: #218838; } #btn-cancel-placement:hover, #btn-cancel-move:hover { background-color: #c82333; }
        #context-menu { position: absolute; display: none; flex-direction: column; gap: 5px; background-color: white; border: 1px solid #ccc; border-radius: 5px; padding: 8px; box-shadow: 0 2px 5px rgba(0,0,0,0.2); z-index: 30; min-width: 140px; }
        #context-menu button { display: flex; align-items: center; gap: 8px; width: 100%; padding: 6px 10px; font-size: 14px; text-align: left; background-color: transparent; border: none; border-radius: 3px; cursor: pointer; color: #343a40; }
        #context-menu button:hover { background-color: #e9ecef; }
        #help-bar { background-color: #343a40; color: #f8f9fa; padding: 6px 12px; font-size: 13px; text-align: center; border-top: 1px solid #495057; flex-shrink: 0; z-index: 5; box-shadow: 0 -1px 3px rgba(0,0,0,0.1); }
        #help-bar kbd { background-color: #6c757d; color: #fff; padding: 1px 4px; border-radius: 3px; border: 1px solid #495057; font-family: monospace; font-size: 12px; margin: 0 2px; display: inline-block; line-height: 1.2; }
    </style>
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.163.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.163.0/examples/jsm/"
            }
        }
    </script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="toolbar">
        <button id="tool-select" class="active" title="Sélectionner / Naviguer (S)"><i class="fas fa-mouse-pointer fa-fw"></i></button>
        <button id="tool-add" title="Ajouter Élément (A)"><i class="fas fa-plus fa-fw"></i></button>
        <button id="tool-move" class="disabled" title="Déplacer Élément (M)"><i class="fas fa-arrows-alt fa-fw"></i></button>
        <button id="tool-rotate" class="disabled" title="Rotation Sélection 45° (R)"><i class="fas fa-sync-alt fa-fw"></i></button>
        <button id="tool-duplicate" class="disabled" title="Dupliquer Élément (D)"><i class="fas fa-copy fa-fw"></i></button>
        <button id="tool-delete" class="disabled" title="Supprimer Sélection (Suppr)"><i class="fas fa-trash-alt fa-fw"></i></button>

        <div class="toolbar-group">
            <div id="element-size-group">
                <label for="element-select">Élément:</label>
                <select id="element-select"></select>
                <div id="size-select-group">
                    <label for="size-select">Taille:</label>
                    <select id="size-select"></select>
                </div>
            </div>
            <label for="joint-thickness" style="margin-left: 10px;">Joint(cm):</label> <input type="number" id="joint-thickness" value="1.2" step="0.1" min="0">
        </div>

        <div class="toolbar-group">
             <label for="assise-select">Assise:</label>
             <select id="assise-select"></select>
             <button id="btn-create-assise" title="Créer Assise à partir de l'élément sélectionné"><i class="fas fa-layer-group fa-fw"></i> Assise</button>
        </div>

        <div id="custom-element-group">
            <label for="custom-name">Nom:</label> <input type="text" id="custom-name" value="Perso">
            <label for="custom-width">L(cm):</label> <input type="number" id="custom-width" value="20" step="0.1" min="0.1">
            <label for="custom-height">H(cm):</label> <input type="number" id="custom-height" value="10" step="0.1" min="0.1">
            <label for="custom-depth">P(cm):</label> <input type="number" id="custom-depth" value="10" step="0.1" min="0.1">
        </div>

        <div class="toolbar-group">
             <label>Vues:</label>
             <button id="btn-view-front" class="view-button" title="Vue de Face (Z+)">F</button>
             <button id="btn-view-back" class="view-button" title="Vue Arrière (Z-)">B</button>
             <button id="btn-view-left" class="view-button" title="Vue Gauche (X-)">G</button>
             <button id="btn-view-right" class="view-button" title="Vue Droite (X+)">D</button>
             <button id="btn-view-top" class="view-button" title="Vue Dessus (Y+)">H</button>
             <button id="btn-view-bottom" class="view-button" title="Vue Dessous (Y-)">B</button>
             <button id="btn-view-iso" class="view-button" title="Vue Isométrique/3D">3D</button>
        </div>

        <div class="toolbar-group">
            <button id="btn-export-pdf" title="Exporter les vues en PDF A4 Portrait"><i class="fas fa-file-pdf fa-fw"></i> Exporter PDF</button>
        </div>

        <span class="info-text">Mode: Sélection / Navigation</span>
    </div>

    <div id="viewport-container">
         <div id="watermark">MurSimulateur3D v.0.0.8 par J.Brohez</div> <div id="placement-controls">
             <div id="dpad-container">
                 <div id="placement-rotation">
                     <button id="placement-rotate-left" title="Rotation Gauche 45° (Q)"><i class="fas fa-undo-alt"></i></button>
                     <button id="placement-rotate-right" title="Rotation Droite 45° (E)"><i class="fas fa-redo-alt"></i></button>
                 </div>
                 <div id="dpad">
                     <button id="dpad-up" title="Avancer (Z-)"><i class="fas fa-arrow-up"></i></button>
                     <button id="dpad-left" title="Gauche (X-)"><i class="fas fa-arrow-left"></i></button>
                     <button id="dpad-right" title="Droite (X+)"><i class="fas fa-arrow-right"></i></button>
                     <button id="dpad-down" title="Reculer (Z+)"><i class="fas fa-arrow-down"></i></button>
                 </div>
                 <div id="placement-vertical">
                      <button id="dpad-up-y" title="Monter (Y+/PgUp)"><i class="fas fa-chevron-up"></i></button>
                      <button id="dpad-down-y" title="Descendre (Y-/PgDn)"><i class="fas fa-chevron-down"></i></button>
                 </div>
             </div>
             <div id="placement-actions">
                 <button id="btn-place-element" title="Placer Élément (Entrée)"><i class="fas fa-check"></i></button>
                 <button id="btn-confirm-move" title="Confirmer Déplacement (Entrée)"><i class="fas fa-check"></i></button>
                 <button id="btn-cancel-placement" title="Annuler Placement (Échap)"><i class="fas fa-times"></i></button>
                 <button id="btn-cancel-move" title="Annuler Déplacement (Échap)"><i class="fas fa-times"></i></button>
             </div>
         </div>
         <div id="context-menu">
             <button id="ctx-rotate"><i class="fas fa-sync-alt fa-fw"></i>Rotation 45°</button>
             <button id="ctx-move"><i class="fas fa-arrows-alt fa-fw"></i>Déplacer</button>
             <button id="ctx-duplicate"><i class="fas fa-copy fa-fw"></i>Dupliquer</button>
             <button id="ctx-delete"><i class="fas fa-trash-alt fa-fw"></i>Supprimer</button>
         </div>
    </div>

    <div id="help-bar">Aide contextuelle apparaîtra ici...</div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // Make jsPDF globally available after import
        const { jsPDF } = window.jspdf;

        // --- Constants ---
        const GRID_SIZE_CM = 1000;
        const GRID_STEP_CM = 50;
        const CUSTOM_ELEMENT_ID = "custom";
        const DEFAULT_CUSTOM_COLOR = 0xAAAAAA;
        const SELECTION_COLOR = 0xffaa00;
        const CLICK_THRESHOLD = 200;
        const LONG_PRESS_THRESHOLD = 500;
        const DPAD_INCREMENT_CM = 1;
        const ROTATION_INCREMENT = Math.PI / 4;
        const DRAG_THRESHOLD_PX = 5;
        const POSE_LIBRE_ID = "pose-libre";
        const VIEW_PADDING_FACTOR = 1.15;
        const MIN_VIEW_SIZE = 50;
        const INITIAL_CAMERA_HEIGHT_CM = 170;
        const INITIAL_TARGET_Y_OFFSET = 50; // Look slightly down towards Y=50 initially

        // --- DOM Elements ---
        const viewportContainer = document.getElementById('viewport-container');
        const toolbar = document.getElementById('toolbar');
        const elementSelect = document.getElementById('element-select');
        const sizeSelectGroup = document.getElementById('size-select-group'); // New group
        const sizeSelect = document.getElementById('size-select');       // New select
        const jointInput = document.getElementById('joint-thickness');
        const infoText = document.querySelector('.info-text');
        const selectToolButton = document.getElementById('tool-select');
        const addToolButton = document.getElementById('tool-add');
        const moveToolButton = document.getElementById('tool-move');
        const rotateToolButton = document.getElementById('tool-rotate');
        const duplicateToolButton = document.getElementById('tool-duplicate');
        const deleteToolButton = document.getElementById('tool-delete');
        const toolButtons = [selectToolButton, addToolButton, moveToolButton, rotateToolButton, duplicateToolButton, deleteToolButton];
        const customElementGroup = document.getElementById('custom-element-group');
        const customNameInput = document.getElementById('custom-name');
        const customWidthInput = document.getElementById('custom-width');
        const customHeightInput = document.getElementById('custom-height');
        const customDepthInput = document.getElementById('custom-depth');
        const btnViewFront = document.getElementById('btn-view-front');
        const btnViewBack = document.getElementById('btn-view-back');
        const btnViewLeft = document.getElementById('btn-view-left');
        const btnViewRight = document.getElementById('btn-view-right');
        const btnViewTop = document.getElementById('btn-view-top');
        const btnViewBottom = document.getElementById('btn-view-bottom');
        const btnViewIso = document.getElementById('btn-view-iso');
        const btnExportPdf = document.getElementById('btn-export-pdf');
        const placementControlsDiv = document.getElementById('placement-controls');
        const dpadUp = document.getElementById('dpad-up');
        const dpadDown = document.getElementById('dpad-down');
        const dpadLeft = document.getElementById('dpad-left');
        const dpadRight = document.getElementById('dpad-right');
        const placementRotateLeft = document.getElementById('placement-rotate-left');
        const placementRotateRight = document.getElementById('placement-rotate-right');
        const dpadUpY = document.getElementById('dpad-up-y');
        const dpadDownY = document.getElementById('dpad-down-y');
        const placeButton = document.getElementById('btn-place-element');
        const confirmMoveButton = document.getElementById('btn-confirm-move');
        const cancelPlacementButton = document.getElementById('btn-cancel-placement');
        const cancelMoveButton = document.getElementById('btn-cancel-move');
        const contextMenu = document.getElementById('context-menu');
        const ctxRotateButton = document.getElementById('ctx-rotate');
        const ctxMoveButton = document.getElementById('ctx-move');
        const ctxDuplicateButton = document.getElementById('ctx-duplicate');
        const ctxDeleteButton = document.getElementById('ctx-delete');
        const assiseSelect = document.getElementById('assise-select');
        const createAssiseButton = document.getElementById('btn-create-assise');
        const helpBar = document.getElementById('help-bar');


        // --- Element Type Definitions (Dimensions in cm: width, height, depth) ---
        // Using baseDim and optional fractions object
        const elementTypes = {
            // Standard Bricks (19cm length base)
            "M50": { name: "Brique M50", baseDim: [19, 5, 9], color: 0xCC6633, fractions: { '1': 19, '3/4': 14, '1/2': 9, '1/4': 4 } },
            "M57": { name: "Brique M57", baseDim: [19, 5.7, 9], color: 0xCC6633, fractions: { '1': 19, '3/4': 14, '1/2': 9, '1/4': 4 } },
            "M65": { name: "Brique M65", baseDim: [19, 6.5, 9], color: 0xCC6633, fractions: { '1': 19, '3/4': 14, '1/2': 9, '1/4': 4 } },
            "M90": { name: "Brique M90", baseDim: [19, 9, 9], color: 0xCC6633, fractions: { '1': 19, '3/4': 14, '1/2': 9, '1/4': 4 } },

            // Other Bricks (no fractions defined)
            "WF": { name: "Brique WF", baseDim: [21, 5, 10], color: 0xD2691E },
            "WFD": { name: "Brique WFD", baseDim: [21, 6.5, 10], color: 0xD2691E },
            // Champ Bricks
            "M50c": { name: "M50 champ", baseDim: [9, 19, 5], color: 0xB87333 },
            "M57c": { name: "M57 champ", baseDim: [9, 19, 5.7], color: 0xB87333 },
            "M65c": { name: "M65 champ", baseDim: [9, 19, 6.5], color: 0xB87333 },
            "M90c": { name: "M90 champ", baseDim: [9, 19, 9], color: 0xB87333 },
            "WFc": { name: "WF champ", baseDim: [10, 21, 5], color: 0xC0C0C0 },
            "WFDc": { name: "WFD champ", baseDim: [10, 21, 6.5], color: 0xC0C0C0 },
            // Blocks
            "B9": { name: "Bloc 9", baseDim: [39, 19, 9], color: 0xAAAAAA },
            "B14": { name: "Bloc 14", baseDim: [39, 19, 14], color: 0xAAAAAA },
            "B19": { name: "Bloc 19", baseDim: [39, 19, 19], color: 0xAAAAAA },
            "B29": { name: "Bloc 29", baseDim: [39, 19, 29], color: 0xAAAAAA },
            // Voids
            "V1": { name: "Vide 1cm", baseDim: [40, 19, 1], color: 0xDDDDDD },
            "V2": { name: "Vide 2cm", baseDim: [40, 19, 2], color: 0xDDDDDD },
            "V3": { name: "Vide 3cm", baseDim: [40, 19, 3], color: 0xDDDDDD },
            "V4": { name: "Vide 4cm", baseDim: [40, 19, 4], color: 0xDDDDDD },
            "V5": { name: "Vide 5cm", baseDim: [40, 19, 5], color: 0xDDDDDD },
            // Lintels
            "L120_14": { name: "Lint 120x14", baseDim: [120, 19, 14], color: 0x888888 }, "L140_14": { name: "Lint 140x14", baseDim: [140, 19, 14], color: 0x888888 }, "L160_14": { name: "Lint 160x14", baseDim: [160, 19, 14], color: 0x888888 }, "L180_14": { name: "Lint 180x14", baseDim: [180, 19, 14], color: 0x888888 }, "L200_14": { name: "Lint 200x14", baseDim: [200, 19, 14], color: 0x888888 }, "L220_14": { name: "Lint 220x14", baseDim: [220, 19, 14], color: 0x888888 }, "L240_14": { name: "Lint 240x14", baseDim: [240, 19, 14], color: 0x888888 }, "L260_14": { name: "Lint 260x14", baseDim: [260, 19, 14], color: 0x888888 }, "L280_14": { name: "Lint 280x14", baseDim: [280, 19, 14], color: 0x888888 }, "L300_14": { name: "Lint 300x14", baseDim: [300, 19, 14], color: 0x888888 },
            "L100_9": { name: "Lint 100x9", baseDim: [100, 19, 9], color: 0x888888 }, "L120_9": { name: "Lint 120x9", baseDim: [120, 19, 9], color: 0x888888 }, "L160_9": { name: "Lint 160x9", baseDim: [160, 19, 9], color: 0x888888 }, "L180_9": { name: "Lint 180x9", baseDim: [180, 19, 9], color: 0x888888 }, "L200_9": { name: "Lint 200x9", baseDim: [200, 19, 9], color: 0x888888 }, "L220_9": { name: "Lint 220x9", baseDim: [220, 19, 9], color: 0x888888 }, "L240_9": { name: "Lint 240x9", baseDim: [240, 19, 9], color: 0x888888 }, "L260_9": { name: "Lint 260x9", baseDim: [260, 19, 9], color: 0x888888 }, "L280_9": { name: "Lint 280x9", dim: [280, 19, 9], color: 0x888888 }, "L300_9": { name: "Lint 300x9", baseDim: [300, 19, 9], color: 0x888888 },
            "L100_19": { name: "Lint 100x19", baseDim: [100, 19, 19], color: 0x888888 }, "L120_19": { name: "Lint 120x19", baseDim: [120, 19, 19], color: 0x888888 }, "L160_19": { name: "Lint 160x19", baseDim: [160, 19, 19], color: 0x888888 }, "L180_19": { name: "Lint 180x19", baseDim: [180, 19, 19], color: 0x888888 }, "L200_19": { name: "Lint 200x19", baseDim: [200, 19, 19], color: 0x888888 }, "L220_19": { name: "Lint 220x19", baseDim: [220, 19, 19], color: 0x888888 }, "L240_19": { name: "Lint 240x19", baseDim: [240, 19, 19], color: 0x888888 }, "L260_19": { name: "Lint 260x19", baseDim: [260, 19, 19], color: 0x888888 }, "L280_19": { name: "Lint 280x19", baseDim: [280, 19, 19], color: 0x888888 }, "L300_19": { name: "Lint 300x19", baseDim: [300, 19, 19], color: 0x888888 },
            // Cellular Concrete
            "BCA60_9": { name: "BC Ass 60x9", baseDim: [60, 20, 9], color: 0xE0E0E0 }, "BCA60_14": { name: "BC Ass 60x14", baseDim: [60, 20, 14], color: 0xE0E0E0 }, "BCA60_19": { name: "BC Ass 60x19", baseDim: [60, 20, 19], color: 0xE0E0E0 },
            "BC60_10": { name: "BC 60x10", baseDim: [60, 25, 10], color: 0xF0F0F0 }, "BC60_15": { name: "BC 60x15", baseDim: [60, 25, 15], color: 0xF0F0F0 }, "BC60_20": { name: "BC 60x20", baseDim: [60, 25, 20], color: 0xF0F0F0 }, "BC60_24": { name: "BC 60x24", baseDim: [60, 25, 24], color: 0xF0F0F0 }, "BC60_30": { name: "BC 60x30", baseDim: [60, 25, 30], color: 0xF0F0F0 }, "BC60_36": { name: "BC 60x36.5", baseDim: [60, 25, 36.5], color: 0xF0F0F0 },
            // Insulation
            "PUR5": { name: "PUR 5cm", baseDim: [120, 60, 5], color: 0xFFFF99 }, "PUR6": { name: "PUR 6cm", baseDim: [120, 60, 6], color: 0xFFFF99 }, "PUR7": { name: "PUR 7cm", baseDim: [120, 60, 7], color: 0xFFFF99 }, "PUR8": { name: "PUR 8cm", baseDim: [120, 60, 8], color: 0xFFFF99 }, "PUR9": { name: "PUR 9cm", baseDim: [120, 60, 9], color: 0xFFFF99 }, "PUR10": { name: "PUR 10cm", baseDim: [120, 60, 10], color: 0xFFFF99 }, "PUR11": { name: "PUR 11cm", baseDim: [120, 60, 11], color: 0xFFFF99 }, "PUR12": { name: "PUR 12cm", baseDim: [120, 60, 12], color: 0xFFFF99 }, "PUR13": { name: "PUR 13cm", baseDim: [120, 60, 13], color: 0xFFFF99 }, "PUR14": { name: "PUR 14cm", baseDim: [120, 60, 14], color: 0xFFFF99 }, "PUR15": { name: "PUR 15cm", baseDim: [120, 60, 15], color: 0xFFFF99 }, "PUR16": { name: "PUR 16cm", baseDim: [120, 60, 16], color: 0xFFFF99 }, "PUR18": { name: "PUR 18cm", baseDim: [120, 60, 18], color: 0xFFFF99 },
            // Profile
            "PROFIL": { name: "Profil", baseDim: [250, 6.5, 6.5], color: 0xC0C0C0 }
        };

        // --- State Variables ---
        let currentTool = 'select';
        let addState = 'idle';
        let moveState = 'idle';
        let selectedElementTypeId = Object.keys(elementTypes)[0]; // ID of the BASE element type
        let selectedFractionKey = '1'; // Key for the selected size ('1', '3/4', '1/2', '1/4')
        let jointThicknessCm = parseFloat(jointInput.value) || 1.2;
        let placedElements = []; // Stores {id, baseTypeId, fractionKey | null, placedDim, mesh, customName?}
        let nextElementId = 0;
        let selectedElement = null;
        let elementForContextMenu = null;
        let isDragging = false;
        let pointerDownTime = 0;
        let longPressTimer = null;
        let originalMovePosition = null;
        let pointerDownCoords = { x: 0, y: 0 };
        let lastPerspectiveCameraState = null;

        // Assise Management
        let assises = [{ id: POSE_LIBRE_ID, name: "Pose Libre", height: null }];
        let activeAssiseId = POSE_LIBRE_ID;

        // --- Three.js Core Components ---
        let scene, camera, renderer, controls, raycaster, pointer, axesHelper, gridHelper;
        let groundPlane, ghostElement;
        const objectsToRaycast = [];
        let initialCameraPosition;

        /** Initializes the Three.js scene, camera, renderer, controls, lights, and helpers */
        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87CEEB);

            // Camera setup (Perspective) - Adjusted initial view
            const aspect = viewportContainer.clientWidth / viewportContainer.clientHeight;
            camera = new THREE.PerspectiveCamera(50, aspect, 1, GRID_SIZE_CM * 5);
            // Target point slightly above ground zero
            const initialTargetPoint = new THREE.Vector3(0, INITIAL_TARGET_Y_OFFSET, 0);
            // Position the camera at eye level, looking towards the target
            initialCameraPosition = new THREE.Vector3(150, INITIAL_CAMERA_HEIGHT_CM, 150); // Example position
            camera.position.copy(initialCameraPosition);
            camera.lookAt(initialTargetPoint);
            lastPerspectiveCameraState = { position: camera.position.clone(), target: initialTargetPoint.clone() };
            console.log(`Vue initiale: Pos(${initialCameraPosition.x.toFixed(0)}, ${initialCameraPosition.y.toFixed(0)}, ${initialCameraPosition.z.toFixed(0)}), Target(${initialTargetPoint.x.toFixed(0)}, ${initialTargetPoint.y.toFixed(0)}, ${initialTargetPoint.z.toFixed(0)})`);

            // Renderer setup
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(viewportContainer.clientWidth, viewportContainer.clientHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            viewportContainer.appendChild(renderer.domElement);

            // OrbitControls setup
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.1;
            controls.screenSpacePanning = false;
            controls.minDistance = 10; // Increased min distance slightly
            controls.maxDistance = GRID_SIZE_CM * 4;
            controls.maxPolarAngle = Math.PI;
            controls.target.copy(initialTargetPoint); // Set initial target
            controls.listenToKeyEvents(window);
            controls.enabled = true;
            controls.addEventListener('end', () => {
                if (controls.enabled) {
                    lastPerspectiveCameraState = { position: camera.position.clone(), target: controls.target.clone() };
                }
            });
            controls.update();

            // Lighting setup
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.8);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.7);
            directionalLight.position.set(200, 350, 250);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048; directionalLight.shadow.mapSize.height = 2048;
            directionalLight.shadow.camera.near = 50; directionalLight.shadow.camera.far = 1000;
            const shadowCamSize = GRID_SIZE_CM;
            directionalLight.shadow.camera.left = -shadowCamSize; directionalLight.shadow.camera.right = shadowCamSize;
            directionalLight.shadow.camera.top = shadowCamSize; directionalLight.shadow.camera.bottom = -shadowCamSize;
            directionalLight.shadow.camera.updateProjectionMatrix();
            scene.add(directionalLight);
            const bottomLight = new THREE.DirectionalLight(0xffffff, 0.4);
            bottomLight.position.set(0, -300, 150);
            scene.add(bottomLight);

            // Ground Plane setup
            const planeGeometry = new THREE.PlaneGeometry(GRID_SIZE_CM * 2, GRID_SIZE_CM * 2);
            const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xF0FFF0, side: THREE.DoubleSide });
            groundPlane = new THREE.Mesh(planeGeometry, planeMaterial);
            groundPlane.rotation.x = -Math.PI / 2; groundPlane.position.y = -0.1;
            groundPlane.receiveShadow = true; groundPlane.userData.isGround = true;
            scene.add(groundPlane); objectsToRaycast.push(groundPlane);

            // Grid Helper setup
            gridHelper = new THREE.GridHelper(GRID_SIZE_CM, GRID_SIZE_CM / GRID_STEP_CM, 0x666666, 0xaaaaaa);
            gridHelper.position.y = 0; gridHelper.visible = false; scene.add(gridHelper);

            // Axes Helper setup
            axesHelper = new THREE.AxesHelper(50); axesHelper.position.set(0, 0.1, 0);
            axesHelper.material.linewidth = 2; scene.add(axesHelper);

            // Raycaster and Pointer setup
            raycaster = new THREE.Raycaster(); pointer = new THREE.Vector2();

            // Ghost Element setup
            const ghostMaterial = new THREE.MeshStandardMaterial({ color: 0x00ff00, opacity: 0.6, transparent: true, depthWrite: false });
            ghostElement = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 1), ghostMaterial);
            ghostElement.visible = false; ghostElement.castShadow = false; scene.add(ghostElement);

            // --- Initial UI Setup ---
            populateElementSelector(); // Call this first
            populateAssiseSelector();
            handleElementSelectChange(); // Set initial state based on default selection (calls populateSizeSelector if needed)
            updateUIToolStates();
            updateInfoText();
            updateHelpBar();
            updateGhostGeometry(); // Update ghost based on initial selection
            updateCursor();

            // --- Event Listeners ---
            window.addEventListener('resize', onWindowResize);
            viewportContainer.addEventListener('pointerdown', onPointerDown, false);
            viewportContainer.addEventListener('pointermove', onPointerMove, false);
            viewportContainer.addEventListener('pointerup', onPointerUp, false);
            viewportContainer.addEventListener('contextmenu', (e) => e.preventDefault());
            toolbar.addEventListener('click', handleToolbarClick);
            elementSelect.addEventListener('change', handleElementSelectChange); // Listener for base element
            sizeSelect.addEventListener('change', handleSizeSelectChange);       // Listener for size fraction
            jointInput.addEventListener('change', handleJointThicknessChange);
            customWidthInput.addEventListener('input', updateGhostGeometry);
            customHeightInput.addEventListener('input', updateGhostGeometry);
            customDepthInput.addEventListener('input', updateGhostGeometry);
            customNameInput.addEventListener('input', updateGhostGeometry);
            window.addEventListener('keydown', handleKeyDown);
            dpadUp.addEventListener('click', () => moveGhostWithDPad(0, 0, -DPAD_INCREMENT_CM));
            dpadDown.addEventListener('click', () => moveGhostWithDPad(0, 0, DPAD_INCREMENT_CM));
            dpadLeft.addEventListener('click', () => moveGhostWithDPad(-DPAD_INCREMENT_CM, 0, 0));
            dpadRight.addEventListener('click', () => moveGhostWithDPad(DPAD_INCREMENT_CM, 0, 0));
            placementRotateLeft.addEventListener('click', () => rotateGhost(-ROTATION_INCREMENT));
            placementRotateRight.addEventListener('click', () => rotateGhost(ROTATION_INCREMENT));
            dpadUpY.addEventListener('click', () => moveGhostWithDPadY(1));
            dpadDownY.addEventListener('click', () => moveGhostWithDPadY(-1));
            placeButton.addEventListener('click', confirmAddPlacement);
            confirmMoveButton.addEventListener('click', confirmMovePlacement);
            cancelPlacementButton.addEventListener('click', cancelAddPlacement);
            cancelMoveButton.addEventListener('click', cancelMovePlacement);
            ctxRotateButton.addEventListener('click', handleContextMenuRotate);
            ctxMoveButton.addEventListener('click', handleContextMenuMove);
            ctxDuplicateButton.addEventListener('click', handleContextMenuDuplicate);
            ctxDeleteButton.addEventListener('click', handleContextMenuDelete);
            document.addEventListener('click', handleClickOutsideContextMenu, true);
            assiseSelect.addEventListener('change', handleAssiseSelectChange);
            createAssiseButton.addEventListener('click', handleCreateAssise);

            // Start the animation loop
            animate();
        }

        // --- Tool and UI Management ---
        function setActiveTool(toolName) {
            if (currentTool === toolName && currentTool !== 'select' && toolName !== 'delete') return;
            const previousTool = currentTool;
            if (previousTool === 'add' && addState === 'positioning') cancelAddPlacement();
            if (previousTool === 'move' && moveState === 'moving') cancelMovePlacement();
            else originalMovePosition = null;
            addState = 'idle'; moveState = 'idle'; hideContextMenu();
            if (toolName === 'delete') { if (selectedElement) deleteSelectedElement(); else console.warn("Clic sur Supprimer mais aucun élément sélectionné."); return; }
            currentTool = toolName;
            if (currentTool === 'add' && selectedElement) deselectElement();
            toolButtons.forEach(button => { button.classList.toggle('active', button.id === `tool-${currentTool}`); });
            controls.enabled = (currentTool === 'select');
            ghostElement.visible = (currentTool === 'add' && addState === 'positioning') || (currentTool === 'move' && moveState === 'moving') || (currentTool === 'duplicate' && selectedElement);
            if (selectedElement) { selectedElement.mesh.visible = !(currentTool === 'move' && moveState === 'moving'); }
            placementControlsDiv.style.display = (currentTool === 'add' && addState === 'positioning') || (currentTool === 'move' && moveState === 'moving') ? 'flex' : 'none';
            if (ghostElement.visible) updateGhostGeometry();
            updateUIToolStates(); updateInfoText(); updateHelpBar(); updateCursor();
        }

        function updateUIToolStates() {
            const hasSelection = selectedElement !== null;
            const isPositioning = currentTool === 'add' && addState === 'positioning';
            const isMoving = currentTool === 'move' && moveState === 'moving';
            const isPlacingOrMoving = isPositioning || isMoving;
            const isExporting = btnExportPdf && btnExportPdf.disabled;

            selectToolButton.disabled = isPlacingOrMoving || isExporting;
            addToolButton.disabled = isPlacingOrMoving || isExporting;
            moveToolButton.disabled = isPlacingOrMoving || !hasSelection || isExporting;
            rotateToolButton.disabled = isPlacingOrMoving || !hasSelection || isExporting;
            duplicateToolButton.disabled = isPlacingOrMoving || !hasSelection || isExporting;
            deleteToolButton.disabled = isPlacingOrMoving || !hasSelection || isExporting;

            const manipulationActive = (currentTool === 'duplicate') && hasSelection;
            const disableInputs = manipulationActive || isPlacingOrMoving || isExporting;

            elementSelect.disabled = disableInputs;
            sizeSelect.disabled = disableInputs; // Also disable size select during actions
            jointInput.disabled = disableInputs;
            assiseSelect.disabled = disableInputs;
            createAssiseButton.disabled = disableInputs;

            const disableCustomGroup = disableInputs || (currentTool === 'add' && selectedElementTypeId !== CUSTOM_ELEMENT_ID);
            customElementGroup.style.pointerEvents = disableCustomGroup ? 'none' : 'auto';
            customElementGroup.style.opacity = disableCustomGroup ? 0.5 : 1;
            customNameInput.disabled = disableCustomGroup;
            customWidthInput.disabled = disableCustomGroup;
            customHeightInput.disabled = disableCustomGroup;
            customDepthInput.disabled = disableCustomGroup;

            placeButton.style.display = isPositioning ? 'flex' : 'none';
            cancelPlacementButton.style.display = isPositioning ? 'flex' : 'none';
            confirmMoveButton.style.display = isMoving ? 'flex' : 'none';
            cancelMoveButton.style.display = isMoving ? 'flex' : 'none';

            btnViewFront.disabled = isPlacingOrMoving || isExporting;
            btnViewBack.disabled = isPlacingOrMoving || isExporting;
            btnViewLeft.disabled = isPlacingOrMoving || isExporting;
            btnViewRight.disabled = isPlacingOrMoving || isExporting;
            btnViewTop.disabled = isPlacingOrMoving || isExporting;
            btnViewBottom.disabled = isPlacingOrMoving || isExporting;
            btnViewIso.disabled = isPlacingOrMoving || isExporting;
        }

        function updateCursor() { viewportContainer.classList.remove('crosshair-cursor', 'pointer-cursor'); if ((currentTool === 'add' && addState === 'idle') || (currentTool === 'move' && moveState === 'idle' && selectedElement) || currentTool === 'duplicate' && selectedElement) { viewportContainer.classList.add('crosshair-cursor'); } else if (currentTool === 'select') { viewportContainer.classList.add('pointer-cursor'); } else { viewportContainer.style.cursor = 'default'; } }
        function handleToolbarClick(event) { const button = event.target.closest('button'); if (!button || button.disabled) return; const buttonId = button.id; if (buttonId.startsWith('btn-view-')) { const viewType = buttonId.substring(9); setView(viewType); return; } if (buttonId === 'btn-export-pdf') { exportToPDF(); return; } if (buttonId === 'btn-create-assise') { handleCreateAssise(); return; } if (buttonId.startsWith('tool-')) { const toolName = buttonId.substring(5); if (toolName === 'rotate') { if (selectedElement) rotateSelectedElement(); else console.warn("Clic sur Rotation mais aucun élément sélectionné."); } else if (toolName === 'delete') { setActiveTool('delete'); } else if (toolName === 'move') { if (selectedElement) triggerMove(); else console.warn("Clic sur Déplacer mais aucun élément sélectionné."); } else if (toolName === 'duplicate') { if (selectedElement) triggerDuplicate(); else console.warn("Clic sur Dupliquer mais aucun élément sélectionné."); } else { setActiveTool(toolName); } } }

        // --- Help Bar ---
        function updateHelpBar() {
            let helpHTML = "";
            const kbd = (key) => `<kbd>${key}</kbd>`;

            switch (currentTool) {
                case 'select':
                    if (selectedElement) {
                        helpHTML = `Sélection: ${kbd('M')} Déplacer | ${kbd('R')} Rotation | ${kbd('D')} Dupliquer | ${kbd('Suppr')} Supprimer | ${kbd('Échap')} Désélectionner | Clic long: Menu`;
                    } else {
                        helpHTML = `Navigation: Clic/Glisser: Orbiter | Molette: Zoom | Clic: Sélectionner | Clic long: Menu | ${kbd('S')} Sélection`;
                    }
                    break;
                case 'add':
                    if (addState === 'positioning') {
                        helpHTML = `Positionnement: Flèches/ ${kbd('PgUp')}/${kbd('PgDn')}: Ajuster | ${kbd('Q')}/${kbd('E')}: Rotation | ${kbd('Entrée')}: Placer | ${kbd('Échap')}: Annuler`;
                    } else {
                        helpHTML = `Ajouter: Clic/Taper: Démarrer positionnement | ${kbd('A')} Ajouter`;
                    }
                    break;
                case 'move':
                    if (moveState === 'moving') {
                        helpHTML = `Déplacement: Flèches/ ${kbd('PgUp')}/${kbd('PgDn')}: Ajuster | ${kbd('Q')}/${kbd('E')}: Rotation | ${kbd('Entrée')}: Confirmer | ${kbd('Échap')}: Annuler`;
                    } else {
                        helpHTML = `Déplacer: Sélectionnez un élément puis ${kbd('M')} ou Menu contextuel | ${kbd('M')} Déplacer`;
                    }
                    break;
                case 'duplicate':
                     helpHTML = `Dupliquer: Clic/Taper: Placer la copie | ${kbd('Échap')}: Annuler | ${kbd('D')} Dupliquer`;
                     break;
                default:
                    helpHTML = "Barre d'aide";
            }
            helpBar.innerHTML = helpHTML;
        }


        // --- Helper: Calculate Scene Bounding Box ---
        function calculateSceneBoundingBox() { const box = new THREE.Box3(); if (placedElements.length === 0) { return box; } placedElements.forEach(element => { element.mesh.updateMatrixWorld(true); box.expandByObject(element.mesh); }); if (box.isEmpty()) { } return box; }

        // --- Camera View Functions ---
        function setView(viewType) { if (!controls) return; controls.enabled = false; const boundingBox = calculateSceneBoundingBox(); const center = new THREE.Vector3(); const size = new THREE.Vector3(); if (!boundingBox.isEmpty()) { boundingBox.getCenter(center); boundingBox.getSize(size); } else { center.copy(lastPerspectiveCameraState ? lastPerspectiveCameraState.target : initialCameraPosition); size.set(MIN_VIEW_SIZE, MIN_VIEW_SIZE, MIN_VIEW_SIZE); } size.x = Math.max(size.x, MIN_VIEW_SIZE); size.y = Math.max(size.y, MIN_VIEW_SIZE); size.z = Math.max(size.z, MIN_VIEW_SIZE); let requiredSize = 0; const aspect = viewportContainer.clientWidth / viewportContainer.clientHeight; let position = new THREE.Vector3(); let up = new THREE.Vector3(0, 1, 0); switch (viewType) { case 'front': requiredSize = Math.max(size.x / aspect, size.y); position.set(center.x, center.y, center.z + requiredSize * 0.5 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * VIEW_PADDING_FACTOR); up.set(0, 1, 0); break; case 'back': requiredSize = Math.max(size.x / aspect, size.y); position.set(center.x, center.y, center.z - requiredSize * 0.5 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * VIEW_PADDING_FACTOR); up.set(0, 1, 0); break; case 'left': requiredSize = Math.max(size.z / aspect, size.y); position.set(center.x - requiredSize * 0.5 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * VIEW_PADDING_FACTOR, center.y, center.z); up.set(0, 1, 0); break; case 'right': requiredSize = Math.max(size.z / aspect, size.y); position.set(center.x + requiredSize * 0.5 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * VIEW_PADDING_FACTOR, center.y, center.z); up.set(0, 1, 0); break; case 'top': requiredSize = Math.max(size.x / aspect, size.z); position.set(center.x, center.y + requiredSize * 0.5 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * VIEW_PADDING_FACTOR, center.z); up.set(0, 0, -1); break; case 'bottom': requiredSize = Math.max(size.x / aspect, size.z); position.set(center.x, center.y - requiredSize * 0.5 / Math.tan(THREE.MathUtils.degToRad(camera.fov * 0.5)) * VIEW_PADDING_FACTOR, center.z); up.set(0, 0, 1); break; case 'iso': default: if (lastPerspectiveCameraState) { position.copy(lastPerspectiveCameraState.position); center.copy(lastPerspectiveCameraState.target); up.set(0, 1, 0); controls.enabled = true; } else { position.copy(initialCameraPosition); center.copy(initialCameraPosition); up.set(0, 1, 0); controls.enabled = true; } break; } camera.position.copy(position); camera.up.copy(up); camera.lookAt(center); controls.target.copy(center); controls.update(); }

        // --- PDF Export Function ---
        async function exportToPDF() { if (!jsPDF) { console.error("jsPDF library is not loaded!"); alert("Erreur : La bibliothèque d'exportation PDF n'a pas pu être chargée."); return; } console.log("Début de l'exportation PDF Ortho+3D..."); btnExportPdf.disabled = true; btnExportPdf.textContent = "Exportation..."; updateInfoText(); const currentControlsTarget = controls.target.clone(); const currentCameraState = { position: camera.position.clone(), rotation: camera.rotation.clone(), up: camera.up.clone(), fov: camera.fov, aspect: camera.aspect, near: camera.near, far: camera.far, zoom: camera.zoom }; const controlsWereEnabled = controls.enabled; controls.enabled = false; const doc = new jsPDF({ orientation: 'portrait', unit: 'mm', format: 'a4' }); const viewsToExport = [ { type: 'front', title: 'Vue de Face (Orthogonale)', ortho: true }, { type: 'back', title: 'Vue Arrière (Orthogonale)', ortho: true }, { type: 'left', title: 'Vue de Gauche (Orthogonale)', ortho: true }, { type: 'right', title: 'Vue de Droite (Orthogonale)', ortho: true }, { type: 'top', title: 'Vue de Dessus (Orthogonale)', ortho: true }, { type: 'iso', title: 'Vue Isométrique (Perspective)', ortho: false } ]; const a4WidthMm = 210; const a4HeightMm = 297; const marginMm = 15; const usableWidthMm = a4WidthMm - 2 * marginMm; const usableHeightMm = a4HeightMm - 2 * marginMm - 15; const boundingBox = calculateSceneBoundingBox(); const center = new THREE.Vector3(); const size = new THREE.Vector3(); let hasObjects = !boundingBox.isEmpty(); if (hasObjects) { boundingBox.getCenter(center); boundingBox.getSize(size); } else { center.set(0, MIN_VIEW_SIZE * 0.5, 0); size.set(MIN_VIEW_SIZE, MIN_VIEW_SIZE, MIN_VIEW_SIZE); console.warn("Export PDF: Aucun objet à exporter, utilisation de la zone par défaut."); } size.x = Math.max(size.x, MIN_VIEW_SIZE * 0.5); size.y = Math.max(size.y, MIN_VIEW_SIZE * 0.5); size.z = Math.max(size.z, MIN_VIEW_SIZE * 0.5); const orthoNear = 0.1; const orthoFar = GRID_SIZE_CM * 5; const orthoCamera = new THREE.OrthographicCamera( -1, 1, 1, -1, orthoNear, orthoFar ); try { for (let i = 0; i < viewsToExport.length; i++) { const view = viewsToExport[i]; if (i > 0) { doc.addPage(); } let renderCamera; if (view.ortho) { renderCamera = orthoCamera; const aspect = usableWidthMm / usableHeightMm; let halfWidth, halfHeight; switch (view.type) { case 'front': case 'back': halfWidth = Math.max(size.x, size.y * aspect) * 0.5 * VIEW_PADDING_FACTOR; halfHeight = halfWidth / aspect; orthoCamera.position.set(center.x, center.y, center.z + (view.type === 'front' ? size.z + orthoFar * 0.5 : -size.z - orthoFar * 0.5)); orthoCamera.up.set(0, 1, 0); break; case 'left': case 'right': halfWidth = Math.max(size.z, size.y * aspect) * 0.5 * VIEW_PADDING_FACTOR; halfHeight = halfWidth / aspect; orthoCamera.position.set(center.x + (view.type === 'left' ? -size.x - orthoFar * 0.5 : size.x + orthoFar * 0.5), center.y, center.z); orthoCamera.up.set(0, 1, 0); break; case 'top': case 'bottom': halfWidth = Math.max(size.x, size.z * aspect) * 0.5 * VIEW_PADDING_FACTOR; halfHeight = halfWidth / aspect; orthoCamera.position.set(center.x, center.y + (view.type === 'top' ? size.y + orthoFar * 0.5 : -size.y - orthoFar * 0.5), center.z); orthoCamera.up.set(0, 0, view.type === 'top' ? -1 : 1); break; } orthoCamera.left = -halfWidth; orthoCamera.right = halfWidth; orthoCamera.top = halfHeight; orthoCamera.bottom = -halfHeight; orthoCamera.lookAt(center); orthoCamera.updateProjectionMatrix(); } else { renderCamera = camera; if (lastPerspectiveCameraState) { camera.position.copy(lastPerspectiveCameraState.position); camera.lookAt(lastPerspectiveCameraState.target); camera.up.set(0, 1, 0); } else { camera.position.copy(initialCameraPosition); camera.lookAt(initialCameraPosition); camera.up.set(0, 1, 0); } camera.updateProjectionMatrix(); } await new Promise(resolve => setTimeout(resolve, 60)); renderer.render(scene, renderCamera); const imageDataUrl = renderer.domElement.toDataURL('image/png'); doc.setFontSize(12); doc.text(view.title, marginMm, marginMm + 5); const canvasAspect = renderer.domElement.width / renderer.domElement.height; let imgWidthMm = usableWidthMm; let imgHeightMm = imgWidthMm / canvasAspect; if (imgHeightMm > usableHeightMm) { imgHeightMm = usableHeightMm; imgWidthMm = imgHeightMm * canvasAspect; } const imgX = marginMm + (usableWidthMm - imgWidthMm) / 2; const imgY = marginMm + 15; doc.addImage(imageDataUrl, 'PNG', imgX, imgY, imgWidthMm, imgHeightMm); } doc.save('mur_simulateur_vues_ortho.pdf'); console.log("Exportation PDF Ortho+3D terminée."); alert("Exportation PDF terminée : mur_simulateur_vues_ortho.pdf"); } catch (error) { console.error("Erreur lors de la génération du PDF:", error); alert("Une erreur s'est produite lors de la génération du PDF."); } finally { camera.position.copy(currentCameraState.position); camera.rotation.copy(currentCameraState.rotation); camera.up.copy(currentCameraState.up); camera.fov = currentCameraState.fov; camera.aspect = currentCameraState.aspect; camera.near = currentCameraState.near; camera.far = currentCameraState.far; camera.zoom = currentCameraState.zoom; camera.updateProjectionMatrix(); controls.target.copy(currentControlsTarget); controls.enabled = controlsWereEnabled; controls.update(); btnExportPdf.disabled = false; btnExportPdf.innerHTML = '<span class="icon-pdf"></span>Exporter PDF'; updateUIToolStates(); updateInfoText(); renderer.render(scene, camera); } }

        // --- Assise Management ---
        function populateAssiseSelector() { const currentVal = assiseSelect.value; assiseSelect.innerHTML = ''; assises.forEach(assise => { const option = document.createElement('option'); option.value = assise.id; option.textContent = assise.name + (assise.height !== null ? ` (${assise.height.toFixed(1)} cm)` : ''); assiseSelect.appendChild(option); }); if (assises.some(a => a.id === currentVal)) { assiseSelect.value = currentVal; } else { assiseSelect.value = activeAssiseId; } }
        function handleCreateAssise() { const selectedType = getElementTypeForAdd(); if (!selectedType) { alert("Veuillez sélectionner un type d'élément valide..."); return; } const [, elemHeight,] = selectedType.dim; if (typeof elemHeight !== 'number' || elemHeight <= 0) { alert("La hauteur de l'élément sélectionné est invalide..."); return; } const currentJoint = parseFloat(jointInput.value) || 0; const assiseHeight = elemHeight + currentJoint; if (assises.some(a => a.height !== null && Math.abs(a.height - assiseHeight) < 0.01)) { alert(`Une assise de hauteur ${assiseHeight.toFixed(1)} cm existe déjà.`); return; } const newAssiseId = `assise-${Date.now()}`; const newAssiseName = `Assise ${assises.filter(a => a.height !== null).length + 1} (${selectedType.name.split(' ')[0]})`; const newAssise = { id: newAssiseId, name: newAssiseName, height: assiseHeight }; assises.push(newAssise); assises.sort((a, b) => { if (a.height === null) return -1; if (b.height === null) return 1; return a.height - b.height; }); populateAssiseSelector(); activeAssiseId = newAssiseId; assiseSelect.value = activeAssiseId; updateInfoText(); updateHelpBar();}
        function handleAssiseSelectChange() { activeAssiseId = assiseSelect.value; updateInfoText(); updateHelpBar();}
        function getActiveAssiseHeight() { if (activeAssiseId === POSE_LIBRE_ID) return null; const activeAssise = assises.find(a => a.id === activeAssiseId); return activeAssise ? activeAssise.height : null; }

        // --- Selection and Context Menu ---
        function selectElement(elementData, keepContextMenuOpen = false) { if (!elementData || !elementData.mesh || !elementData.mesh.material) { console.error("Tentative de sélection d'un élément invalide:", elementData); return; } if (selectedElement === elementData) { if (!keepContextMenuOpen) hideContextMenu(); return; } deselectElement(); selectedElement = elementData; if (selectedElement.mesh.material.userData.originalEmissive === undefined) { selectedElement.mesh.material.userData.originalEmissive = selectedElement.mesh.material.emissive.getHex(); } selectedElement.mesh.material.emissive.setHex(SELECTION_COLOR); selectedElement.mesh.material.needsUpdate = true; updateUIToolStates(); updateInfoText(); updateHelpBar(); if (!keepContextMenuOpen) hideContextMenu(); }
        function deselectElement() { hideContextMenu(); const wasMoving = currentTool === 'move' && moveState === 'moving'; if (selectedElement && selectedElement.mesh && selectedElement.mesh.material) { const originalEmissive = selectedElement.mesh.material.userData.originalEmissive ?? 0x000000; selectedElement.mesh.material.emissive.setHex(originalEmissive); selectedElement.mesh.material.needsUpdate = true; if (wasMoving && originalMovePosition) { selectedElement.mesh.position.copy(originalMovePosition); selectedElement.mesh.visible = true; } } selectedElement = null; originalMovePosition = null; updateUIToolStates(); updateInfoText(); updateHelpBar(); if (wasMoving) { moveState = 'idle'; placementControlsDiv.style.display = 'none'; setActiveTool('select'); } }
        function showContextMenu(event, elementData) { elementForContextMenu = elementData; selectElement(elementData, true); const menuWidth = contextMenu.offsetWidth; const menuHeight = contextMenu.offsetHeight; const viewportWidth = viewportContainer.clientWidth; const viewportHeight = viewportContainer.clientHeight; let top = event.clientY; let left = event.clientX; if (left + menuWidth > viewportWidth - 10) left = viewportWidth - menuWidth - 10; if (top + menuHeight > viewportHeight - 10) top = viewportHeight - menuHeight - 10; if (left < 10) left = 10; if (top < 10) top = 10; contextMenu.style.left = `${left}px`; contextMenu.style.top = `${top}px`; contextMenu.style.display = 'flex'; }
        function hideContextMenu() { if (contextMenu.style.display !== 'none') { contextMenu.style.display = 'none'; elementForContextMenu = null; } }
        function handleClickOutsideContextMenu(event) { if (contextMenu.style.display === 'flex' && !contextMenu.contains(event.target)) { const rect = renderer.domElement.getBoundingClientRect(); pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(pointer, camera); const placedMeshes = placedElements.map(el => el.mesh).filter(mesh => mesh); const intersects = raycaster.intersectObjects(placedMeshes, false); if (intersects.length === 0 || !elementForContextMenu || intersects[0].object !== elementForContextMenu.mesh) { hideContextMenu(); } } }
        function handleContextMenuRotate() { if (elementForContextMenu) { if (selectedElement !== elementForContextMenu) selectElement(elementForContextMenu); rotateSelectedElement(); } hideContextMenu(); }
        function handleContextMenuMove() { if (elementForContextMenu) { if (selectedElement !== elementForContextMenu) selectElement(elementForContextMenu); triggerMove(); } hideContextMenu(); }
        function handleContextMenuDuplicate() { if (elementForContextMenu) { if (selectedElement !== elementForContextMenu) selectElement(elementForContextMenu); triggerDuplicate(); } hideContextMenu(); }
        function handleContextMenuDelete() { if (elementForContextMenu) { if (selectedElement !== elementForContextMenu) selectElement(elementForContextMenu); deleteSelectedElement(); } hideContextMenu(); }

        // --- Element Data and Geometry ---

        /** Populates the main element selection dropdown with base types */
        function populateElementSelector() {
            elementSelect.innerHTML = ''; // Clear existing options

            // Add the "Custom" option first
            const customOption = document.createElement('option');
            customOption.value = CUSTOM_ELEMENT_ID;
            customOption.textContent = "[ Élément Personnalisé ]";
            elementSelect.appendChild(customOption);

            // Add predefined element types, sorted alphabetically by name
            const sortedKeys = Object.keys(elementTypes).sort((a, b) => {
                const nameA = elementTypes[a].name.toLowerCase();
                const nameB = elementTypes[b].name.toLowerCase();
                if (nameA < nameB) return -1;
                if (nameA > nameB) return 1;
                return 0;
            });

            sortedKeys.forEach(id => {
                const type = elementTypes[id];
                const option = document.createElement('option');
                option.value = id;
                // Display only the base name in the main dropdown
                option.textContent = type.name;
                // Store base dimensions as data attribute for potential use (optional)
                option.dataset.baseDim = JSON.stringify(type.baseDim);
                elementSelect.appendChild(option);
            });

            // Set the initial selection (first predefined element or custom if none exist)
            const firstPredefinedId = sortedKeys[0];
            if (firstPredefinedId) {
                selectedElementTypeId = firstPredefinedId;
                elementSelect.value = selectedElementTypeId;
            } else {
                selectedElementTypeId = CUSTOM_ELEMENT_ID;
                elementSelect.value = selectedElementTypeId;
            }
            // Trigger initial population of the size selector based on the default element
            handleElementSelectChange();
        }

        /** Populates the size selection dropdown based on the selected element's fractions */
        function populateSizeSelector(fractionsData) {
            sizeSelect.innerHTML = ''; // Clear existing options

            // Define display order and text for fractions
            const fractionOrder = ['1', '3/4', '1/2', '1/4'];
            const fractionLabels = {
                '1': 'Entière',
                '3/4': '3/4',
                '1/2': '1/2',
                '1/4': '1/4'
            };

            fractionOrder.forEach(key => {
                if (fractionsData.hasOwnProperty(key)) {
                    const length = fractionsData[key];
                    const option = document.createElement('option');
                    option.value = key; // Store the key ('1', '3/4', etc.)
                    option.textContent = `${fractionLabels[key]} (${length}cm)`;
                    sizeSelect.appendChild(option);
                }
            });

            // Set default selection to '1' (Entière) if available
            if (fractionsData.hasOwnProperty('1')) {
                sizeSelect.value = '1';
                selectedFractionKey = '1';
            } else if (sizeSelect.options.length > 0) {
                // Fallback to the first available option if '1' is not present
                sizeSelect.selectedIndex = 0;
                selectedFractionKey = sizeSelect.value;
            } else {
                selectedFractionKey = null; // No fractions available
            }
        }


        /**
         * Gets the effective element type definition based on the current selections.
         * Combines base type info with selected fraction (if applicable).
         * @returns {object | null} The element type definition {name, dim, color, isCustom?, baseTypeId?} or null if invalid.
         */
        function getEffectiveElementType() {
            if (selectedElementTypeId === CUSTOM_ELEMENT_ID) {
                // Handle custom element
                const w = parseFloat(customWidthInput.value);
                const h = parseFloat(customHeightInput.value);
                const d = parseFloat(customDepthInput.value);
                const name = customNameInput.value.trim() || "Personnalisé";
                if (isNaN(w) || w <= 0 || isNaN(h) || h <= 0 || isNaN(d) || d <= 0) {
                    console.warn("Dimensions personnalisées invalides.");
                    alert("Les dimensions personnalisées (L, H, P) doivent être des nombres positifs.");
                    return null;
                }
                return { name: name, dim: [w, h, d], color: DEFAULT_CUSTOM_COLOR, isCustom: true };
            }

            // Handle predefined element
            const baseType = elementTypes[selectedElementTypeId];
            if (!baseType) {
                console.error(`Type d'élément de base introuvable: ${selectedElementTypeId}`);
                return null;
            }

            let finalDim;
            let effectiveName = baseType.name; // Start with base name

            if (baseType.fractions && selectedFractionKey) {
                // If fractions are available and a fraction is selected
                const fractionLength = baseType.fractions[selectedFractionKey];
                if (typeof fractionLength !== 'number') {
                    console.error(`Longueur invalide pour la fraction ${selectedFractionKey} de ${selectedElementTypeId}`);
                    return null; // Invalid fraction length
                }
                // Use fraction length (width), keep base height and depth
                finalDim = [fractionLength, baseType.baseDim[1], baseType.baseDim[2]];
                // Adjust name if not the full size
                if (selectedFractionKey !== '1') {
                    effectiveName += ` ${selectedFractionKey}`;
                }
            } else {
                // No fractions available or selected, use base dimensions
                finalDim = [...baseType.baseDim]; // Use a copy
            }

            return {
                name: effectiveName,
                dim: finalDim,
                color: baseType.color,
                isCustom: false,
                baseTypeId: selectedElementTypeId, // Store the base type ID
                fractionKey: selectedFractionKey // Store the selected fraction key
            };
        }


        /**
         * Gets the element type definition for the currently selected element in the scene.
         * Retrieves data stored with the placed element.
         * @returns {object | null} The element type definition {name, dim, color, isCustom?, baseTypeId?, fractionKey?} or null if no valid selection.
         */
        function getElementTypeForSelected() {
            if (!selectedElement) return null;

            // Retrieve stored data from the selected element
            const { baseTypeId, fractionKey, placedDim, customName, mesh } = selectedElement;

            if (baseTypeId === CUSTOM_ELEMENT_ID) {
                // It's a custom element
                 if (!placedDim) {
                     console.error("Données de dimensions placées manquantes pour l'élément personnalisé sélectionné:", selectedElement.id);
                     return null; // Should have placedDim if it was placed correctly
                 }
                return {
                    name: customName || "Personnalisé",
                    dim: placedDim, // Use the dimensions it was placed with
                    color: mesh.material.color.getHex(), // Get current color
                    isCustom: true,
                    baseTypeId: CUSTOM_ELEMENT_ID
                };
            } else {
                // It's a predefined element (possibly fractional)
                const baseType = elementTypes[baseTypeId];
                if (!baseType) {
                    console.error(`Type de base introuvable pour l'élément sélectionné: ${baseTypeId}`);
                    return null;
                }
                 if (!placedDim) {
                     console.error("Données de dimensions placées manquantes pour l'élément prédéfini sélectionné:", selectedElement.id);
                     // Attempt to reconstruct dimensions as fallback
                     const fallbackDim = baseType.fractions && fractionKey ?
                         [baseType.fractions[fractionKey] ?? baseType.baseDim[0], baseType.baseDim[1], baseType.baseDim[2]] :
                         [...baseType.baseDim];
                      return {
                          name: baseType.name + (fractionKey && fractionKey !== '1' ? ` ${fractionKey}` : ''),
                          dim: fallbackDim, // Use reconstructed dimensions
                          color: mesh.material.color.getHex(),
                          isCustom: false,
                          baseTypeId: baseTypeId,
                          fractionKey: fractionKey
                      };
                 }

                // Return data based on stored properties
                return {
                    name: baseType.name + (fractionKey && fractionKey !== '1' ? ` ${fractionKey}` : ''), // Reconstruct name
                    dim: placedDim, // Use the dimensions it was placed with
                    color: mesh.material.color.getHex(), // Get current color from mesh
                    isCustom: false,
                    baseTypeId: baseTypeId,
                    fractionKey: fractionKey
                };
            }
        }

        /** Updates the geometry and color of the ghost element based on the current selections or selected element */
        function updateGhostGeometry() {
            let elementType = null;

            // Determine which element type to use for the ghost
            if (currentTool === 'add') {
                elementType = getEffectiveElementType(); // Use combined base + fraction selection
            } else if ((currentTool === 'move' || currentTool === 'duplicate') && selectedElement) {
                elementType = getElementTypeForSelected(); // Use data from the actual selected element
            } else {
                ghostElement.visible = false;
                return;
            }

            if (!elementType || !elementType.dim) {
                ghostElement.visible = false;
                return;
            };

            const [widthCm, heightCm, depthCm] = elementType.dim;

            // Check if geometry needs updating
            if (!ghostElement.geometry ||
                Math.abs(ghostElement.geometry.parameters.width - widthCm) > 0.01 ||
                Math.abs(ghostElement.geometry.parameters.height - heightCm) > 0.01 ||
                Math.abs(ghostElement.geometry.parameters.depth - depthCm) > 0.01)
            {
                if (ghostElement.geometry) ghostElement.geometry.dispose();
                ghostElement.geometry = new THREE.BoxGeometry(widthCm, heightCm, depthCm);
            }

            // Update ghost color
            ghostElement.material.color.setHex(elementType.color || DEFAULT_CUSTOM_COLOR);
            ghostElement.material.needsUpdate = true;

            // Update ghost rotation
            if ((currentTool === 'move' || currentTool === 'duplicate') && selectedElement) {
                ghostElement.rotation.copy(selectedElement.mesh.rotation);
            } else if (currentTool === 'add') {
                 if (addState === 'idle') {
                     ghostElement.rotation.set(0, 0, 0);
                 }
            }
        }

        // --- Snapping Logic ---
        function snapToGridXZ(value, dimension, joint) { const snapIncrement = Math.max(0.1, joint > 0 ? joint : 1.0); const snappedCenter = Math.round(value / snapIncrement) * snapIncrement; return snappedCenter; }
        function snapVerticalPosition(targetBottomY, elementHeight) { const activeAssiseH = getActiveAssiseHeight(); if (activeAssiseH === null || activeAssiseH <= 0) return Math.max(0, targetBottomY); const snappedBottomY = Math.round(targetBottomY / activeAssiseH) * activeAssiseH; return Math.max(0, snappedBottomY); }

        // --- Raycasting and Ghost Positioning ---
        function calculateSnappedPosition(intersection) { if (!intersection || !ghostElement.geometry || !ghostElement.geometry.parameters) return null; const point = intersection.point; const object = intersection.object; const { width: ghostWidth, height: ghostHeight, depth: ghostDepth } = ghostElement.geometry.parameters; let topYBelow = 0; if (object && !object.userData.isGround && object.geometry && object.geometry.parameters) topYBelow = object.position.y + object.geometry.parameters.height / 2; const potentialBottomY = topYBelow + jointThicknessCm; const snappedBottomY = snapVerticalPosition(potentialBottomY, ghostHeight); const targetCenterY = snappedBottomY + ghostHeight / 2; const targetPoint = point.clone(); const snappedCenterX = snapToGridXZ(targetPoint.x, ghostWidth, jointThicknessCm); const snappedCenterZ = snapToGridXZ(targetPoint.z, ghostDepth, jointThicknessCm); return new THREE.Vector3(snappedCenterX, targetCenterY, snappedCenterZ); }
        function updateGhostPosition(event) { if (!((currentTool === 'add' && addState === 'idle') || (currentTool === 'move' && moveState === 'moving') || (currentTool === 'duplicate' && selectedElement))) { if (ghostElement.visible) ghostElement.visible = false; return; } const rect = renderer.domElement.getBoundingClientRect(); pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(pointer, camera); const activeObjectsToRaycast = objectsToRaycast.filter(obj => !selectedElement || obj !== selectedElement.mesh || currentTool !== 'move'); const intersects = raycaster.intersectObjects(activeObjectsToRaycast, false); if (intersects.length > 0) { const snappedPosition = calculateSnappedPosition(intersects[0]); if (snappedPosition) { ghostElement.position.copy(snappedPosition); if (!ghostElement.visible) ghostElement.visible = true; } else { if (ghostElement.visible) ghostElement.visible = false; } } else { if (ghostElement.visible) ghostElement.visible = false; } }

        // --- Element Actions (Place, Rotate, Delete, Move, Duplicate) ---
        /**
         * Creates and adds a new element mesh to the scene and internal tracking.
         * Uses the effective element type data.
         * @param {object} effectiveElementType - The combined type definition (base + fraction).
         * @param {THREE.Vector3} position - The center position for the new element.
         * @param {THREE.Euler} rotation - The rotation for the new element.
         * @returns {object | null} The data object of the newly placed element or null on failure.
         */
        function placeElement(effectiveElementType, position, rotation) {
            if (!effectiveElementType || !effectiveElementType.dim || effectiveElementType.dim.length !== 3) {
                console.error("placeElement: Type d'élément effectif invalide ou dimensions manquantes.", effectiveElementType);
                return null;
            }

            const [widthCm, heightCm, depthCm] = effectiveElementType.dim; // Use final dimensions

            // Create geometry and material
            const geometry = new THREE.BoxGeometry(widthCm, heightCm, depthCm);
            const material = new THREE.MeshStandardMaterial({
                color: effectiveElementType.color || DEFAULT_CUSTOM_COLOR,
                roughness: 0.8, metalness: 0.1, emissive: 0x000000
            });
            material.userData.originalEmissive = 0x000000;

            // Create mesh
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);
            if (rotation) mesh.rotation.copy(rotation);
            mesh.castShadow = true; mesh.receiveShadow = true;

            // Create data object for tracking
            const elementData = {
                id: nextElementId++,
                mesh: mesh,
                baseTypeId: effectiveElementType.baseTypeId || (effectiveElementType.isCustom ? CUSTOM_ELEMENT_ID : null), // Store base type or custom ID
                fractionKey: effectiveElementType.fractionKey || null, // Store fraction key if applicable
                placedDim: [...effectiveElementType.dim], // Store the actual dimensions used
                ...(effectiveElementType.isCustom && { customName: effectiveElementType.name }) // Store custom name if custom
            };

            // Add to scene and tracking arrays
            placedElements.push(elementData);
            scene.add(mesh);
            objectsToRaycast.push(mesh);

            console.log(`Élément placé: ID=${elementData.id}, BaseID=${elementData.baseTypeId}, Fraction=${elementData.fractionKey || 'N/A'}, Dim=${elementData.placedDim.join('x')}`);
            return elementData;
        }

        function rotateSelectedElement() { if (!selectedElement) { console.warn("Rotation annulée: aucun élément sélectionné."); return; } selectedElement.mesh.rotateY(ROTATION_INCREMENT); if (ghostElement.visible && (currentTool === 'move' || currentTool === 'duplicate')) ghostElement.rotation.copy(selectedElement.mesh.rotation); }
        function deleteSelectedElement() { if (!selectedElement) { console.warn("Suppression annulée: aucun élément sélectionné."); return; } const elementToDelete = selectedElement; const deletedId = elementToDelete.id; scene.remove(elementToDelete.mesh); const raycastIndex = objectsToRaycast.indexOf(elementToDelete.mesh); if (raycastIndex > -1) objectsToRaycast.splice(raycastIndex, 1); else console.warn(`Mesh ${deletedId} non trouvé dans objectsToRaycast.`); const placedIndex = placedElements.findIndex(el => el.id === deletedId); if (placedIndex > -1) placedElements.splice(placedIndex, 1); else console.warn(`Data ${deletedId} non trouvé dans placedElements.`); if (elementToDelete.mesh.geometry) elementToDelete.mesh.geometry.dispose(); if (elementToDelete.mesh.material) elementToDelete.mesh.material.dispose(); selectedElement = null; originalMovePosition = null; updateUIToolStates(); updateInfoText(); updateHelpBar(); }
        function triggerMove() { if (!selectedElement) return; originalMovePosition = selectedElement.mesh.position.clone(); setActiveTool('move'); moveState = 'moving'; updateGhostGeometry(); ghostElement.position.copy(selectedElement.mesh.position); ghostElement.visible = true; selectedElement.mesh.visible = false; placementControlsDiv.style.display = 'flex'; updateUIToolStates(); updateInfoText(); updateCursor(); updateHelpBar(); }
        function triggerDuplicate() { if (!selectedElement) return; setActiveTool('duplicate'); updateGhostGeometry(); ghostElement.position.copy(selectedElement.mesh.position).add(new THREE.Vector3(10, 0, 0)); ghostElement.visible = true; selectedElement.mesh.visible = true; placementControlsDiv.style.display = 'none'; updateUIToolStates(); updateInfoText(); updateCursor(); }
        function placeDuplicateElement() {
            if (currentTool !== 'duplicate' || !selectedElement || !ghostElement.visible) { console.warn("placeDuplicateElement appelé dans un état incorrect."); return; }
            const elementType = getElementTypeForSelected(); // Get data of the original element
            if (!elementType) { console.error("Impossible d'obtenir le type de l'élément original..."); setActiveTool('select'); return; }
            // Use the retrieved elementType (which includes placedDim) for placement
            const newElement = placeElement(elementType, ghostElement.position, ghostElement.rotation);
            if (newElement) selectElement(newElement);
            setActiveTool('select');
        }

        // --- DPad Placement/Move Actions ---
        function moveGhostWithDPad(dx, dy, dz) { if (ghostElement.visible && ((currentTool === 'add' && addState === 'positioning') || (currentTool === 'move' && moveState === 'moving'))) { ghostElement.position.x += dx; ghostElement.position.y += dy; ghostElement.position.z += dz; } }
        function moveGhostWithDPadY(direction) { if (ghostElement.visible && ((currentTool === 'add' && addState === 'positioning') || (currentTool === 'move' && moveState === 'moving'))) { const activeAssiseH = getActiveAssiseHeight(); const { height: ghostHeight } = ghostElement.geometry.parameters; const incrementY = (activeAssiseH !== null && activeAssiseH > 0) ? activeAssiseH : DPAD_INCREMENT_CM; const currentBottomY = ghostElement.position.y - ghostHeight / 2; let newBottomY = currentBottomY + (direction * incrementY); newBottomY = Math.max(0, newBottomY); const snappedBottomY = snapVerticalPosition(newBottomY, ghostHeight); ghostElement.position.y = snappedBottomY + ghostHeight / 2; } }
        function rotateGhost(angle) { if (ghostElement.visible && ((currentTool === 'add' && addState === 'positioning') || (currentTool === 'move' && moveState === 'moving'))) ghostElement.rotateY(angle); }
        function confirmAddPlacement() {
            if (currentTool === 'add' && addState === 'positioning' && ghostElement.visible) {
                const effectiveElementType = getEffectiveElementType(); // Get combined type info
                if (effectiveElementType) {
                    const newElement = placeElement(effectiveElementType, ghostElement.position, ghostElement.rotation);
                    if (newElement) {
                        addState = 'idle'; ghostElement.visible = false; placementControlsDiv.style.display = 'none';
                        updateUIToolStates(); updateInfoText(); updateCursor(); updateHelpBar(); return;
                    }
                }
                console.error("Échec du placement de l'élément."); cancelAddPlacement();
            }
        }
        function cancelAddPlacement() { if (currentTool === 'add' && addState === 'positioning') { addState = 'idle'; ghostElement.visible = false; placementControlsDiv.style.display = 'none'; updateUIToolStates(); updateInfoText(); updateCursor(); updateHelpBar(); } }
        function confirmMovePlacement() { if (currentTool === 'move' && moveState === 'moving' && selectedElement && ghostElement.visible) { selectedElement.mesh.position.copy(ghostElement.position); selectedElement.mesh.rotation.copy(ghostElement.rotation); selectedElement.mesh.visible = true; moveState = 'idle'; originalMovePosition = null; ghostElement.visible = false; placementControlsDiv.style.display = 'none'; setActiveTool('select'); } }
        function cancelMovePlacement() { if (currentTool === 'move' && moveState === 'moving' && selectedElement) { if (originalMovePosition) selectedElement.mesh.position.copy(originalMovePosition); else console.warn("Position originale non disponible..."); selectedElement.mesh.visible = true; moveState = 'idle'; originalMovePosition = null; ghostElement.visible = false; placementControlsDiv.style.display = 'none'; setActiveTool('select'); } }

        // --- Event Handlers ---
        function onWindowResize() { camera.aspect = viewportContainer.clientWidth / viewportContainer.clientHeight; camera.updateProjectionMatrix(); renderer.setSize(viewportContainer.clientWidth, viewportContainer.clientHeight); }
        function onPointerDown(event) { if (toolbar.contains(event.target) || placementControlsDiv.contains(event.target) || contextMenu.contains(event.target)) return; const rect = renderer.domElement.getBoundingClientRect(); const isClickInsideViewport = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom; if (!isClickInsideViewport) return; isDragging = false; pointerDownTime = Date.now(); pointerDownCoords = { x: event.clientX, y: event.clientY }; clearTimeout(longPressTimer); hideContextMenu(); if (currentTool === 'select') { pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(pointer, camera); const placedMeshes = placedElements.map(el => el.mesh).filter(mesh => mesh); const intersects = raycaster.intersectObjects(placedMeshes, false); if (intersects.length > 0) { const elementData = placedElements.find(el => el.mesh === intersects[0].object); if (elementData) { longPressTimer = setTimeout(() => { const distanceMoved = Math.sqrt(Math.pow(event.clientX - pointerDownCoords.x, 2) + Math.pow(event.clientY - pointerDownCoords.y, 2)); if (distanceMoved < DRAG_THRESHOLD_PX) { showContextMenu(event, elementData); pointerDownTime = 0; } }, LONG_PRESS_THRESHOLD); } } } }
        function onPointerMove(event) { if (event.buttons > 0 && pointerDownTime > 0 && !isDragging) { const distanceMoved = Math.sqrt(Math.pow(event.clientX - pointerDownCoords.x, 2) + Math.pow(event.clientY - pointerDownCoords.y, 2)); if (distanceMoved >= DRAG_THRESHOLD_PX) { isDragging = true; clearTimeout(longPressTimer); hideContextMenu(); } } if (!isDragging) { if ((currentTool === 'add' && addState === 'idle') || (currentTool === 'move' && moveState === 'moving') || (currentTool === 'duplicate' && selectedElement)) updateGhostPosition(event); } }
        function onPointerUp(event) { clearTimeout(longPressTimer); if (toolbar.contains(event.target) || placementControlsDiv.contains(event.target) || contextMenu.contains(event.target)) { isDragging = false; pointerDownTime = 0; return; } const clickDuration = Date.now() - pointerDownTime; const rect = renderer.domElement.getBoundingClientRect(); const isClickInsideViewport = event.clientX >= rect.left && event.clientX <= rect.right && event.clientY >= rect.top && event.clientY <= rect.bottom; if (isClickInsideViewport && !isDragging && clickDuration < LONG_PRESS_THRESHOLD && pointerDownTime !== 0) { pointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1; pointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1; raycaster.setFromCamera(pointer, camera); if (currentTool === 'select') { const placedMeshes = placedElements.map(el => el.mesh).filter(mesh => mesh); const intersects = raycaster.intersectObjects(placedMeshes, false); if (intersects.length > 0) { const elementData = placedElements.find(el => el.mesh === intersects[0].object); if (elementData) selectElement(elementData); else { console.warn("Intersection trouvée mais données élément manquantes."); deselectElement(); } } else deselectElement(); } else if (currentTool === 'add') { if (addState === 'idle') { const activeObjectsToRaycast = objectsToRaycast.filter(obj => !selectedElement || obj !== selectedElement.mesh); const intersects = raycaster.intersectObjects(activeObjectsToRaycast, false); if (intersects.length > 0) { const snappedPosition = calculateSnappedPosition(intersects[0]); if (snappedPosition) { addState = 'positioning'; updateGhostGeometry(); ghostElement.position.copy(snappedPosition); ghostElement.visible = true; placementControlsDiv.style.display = 'flex'; updateUIToolStates(); updateInfoText(); updateCursor(); updateHelpBar(); } else console.warn("Clic pour ajouter, mais position calculée invalide."); } } else if (addState === 'positioning') { /* Ignore click */ } } else if (currentTool === 'move') { /* Ignore click */ } else if (currentTool === 'duplicate') { if (selectedElement && ghostElement.visible) placeDuplicateElement(); else setActiveTool('select'); } } isDragging = false; pointerDownTime = 0; }

        /** Handles changes in the main element selection dropdown */
        function handleElementSelectChange(event) {
            selectedElementTypeId = elementSelect.value;
            const selectedTypeData = elementTypes[selectedElementTypeId];

            // Show/hide custom dimension inputs
            customElementGroup.style.display = (selectedElementTypeId === CUSTOM_ELEMENT_ID) ? 'flex' : 'none';

            // Show/hide and populate size dropdown
            if (selectedTypeData && selectedTypeData.fractions) {
                populateSizeSelector(selectedTypeData.fractions);
                sizeSelectGroup.style.display = 'inline-flex'; // Show the group
            } else {
                sizeSelectGroup.style.display = 'none'; // Hide the group
                sizeSelect.innerHTML = ''; // Clear options
                selectedFractionKey = null; // No fraction applicable
            }

            // If in 'add' tool idle state, update the ghost geometry preview
            if (currentTool === 'add' && addState === 'idle') {
                updateGhostGeometry();
                ghostElement.visible = false; // Keep ghost hidden until pointer moves over viewport
            }
            updateUIToolStates();
            updateInfoText();
            updateHelpBar();
        }

         /** Handles changes in the size fraction dropdown */
         function handleSizeSelectChange(event) {
            selectedFractionKey = sizeSelect.value;
            // If in 'add' tool idle state, update the ghost geometry preview
            if (currentTool === 'add' && addState === 'idle') {
                updateGhostGeometry();
                ghostElement.visible = false; // Keep ghost hidden until pointer moves over viewport
            } else if (currentTool === 'add' && addState === 'positioning') {
                 updateGhostGeometry(); // Update ghost immediately if positioning
            }
            updateInfoText(); // Update info text if needed
            updateHelpBar(); // Update help bar if needed
        }


        function handleJointThicknessChange(event) { const value = parseFloat(event.target.value); if (!isNaN(value) && value >= 0) { jointThicknessCm = value; } else event.target.value = jointThicknessCm; }
        function handleKeyDown(event) { if (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'SELECT') return; const key = event.key.toLowerCase(); let helpBarNeedsUpdate = false; if (key === 'escape') { event.preventDefault(); hideContextMenu(); if (currentTool === 'add' && addState === 'positioning') { cancelAddPlacement(); helpBarNeedsUpdate = true; } else if (currentTool === 'move' && moveState === 'moving') { cancelMovePlacement(); helpBarNeedsUpdate = true; } else if (selectedElement) { deselectElement(); helpBarNeedsUpdate = true; } if(helpBarNeedsUpdate) updateHelpBar(); return; } if (key === 'enter') { event.preventDefault(); if (currentTool === 'add' && addState === 'positioning') { confirmAddPlacement(); helpBarNeedsUpdate = true; } else if (currentTool === 'move' && moveState === 'moving') { confirmMovePlacement(); helpBarNeedsUpdate = true; } if(helpBarNeedsUpdate) updateHelpBar(); return; } if (key === 'delete' || key === 'backspace') { if (!deleteToolButton.disabled) { event.preventDefault(); deleteSelectedElement(); helpBarNeedsUpdate = true; } if(helpBarNeedsUpdate) updateHelpBar(); return; } if ((currentTool === 'add' && addState === 'positioning') || (currentTool === 'move' && moveState === 'moving')) { let handled = true; switch(key) { case 'arrowup': case 'w': moveGhostWithDPad(0, 0, -DPAD_INCREMENT_CM); break; case 'arrowdown': case 's': moveGhostWithDPad(0, 0, DPAD_INCREMENT_CM); break; case 'arrowleft': case 'a': moveGhostWithDPad(-DPAD_INCREMENT_CM, 0, 0); break; case 'arrowright': case 'd': moveGhostWithDPad(DPAD_INCREMENT_CM, 0, 0); break; case 'pageup': moveGhostWithDPadY(1); break; case 'pagedown': moveGhostWithDPadY(-1); break; case 'q': rotateGhost(-ROTATION_INCREMENT); break; case 'e': rotateGhost(ROTATION_INCREMENT); break; default: handled = false; break; } if (handled) { event.preventDefault(); return; } } switch(key) { case 's': if (!selectToolButton.disabled) { setActiveTool('select'); helpBarNeedsUpdate = true; } break; case 'a': if (!addToolButton.disabled) { setActiveTool('add'); helpBarNeedsUpdate = true; } break; case 'm': if (!moveToolButton.disabled) { triggerMove(); helpBarNeedsUpdate = true; } break; case 'r': if (!rotateToolButton.disabled) rotateSelectedElement(); break; case 'd': if (!duplicateToolButton.disabled) { triggerDuplicate(); helpBarNeedsUpdate = true; } break; } if(helpBarNeedsUpdate) updateHelpBar(); }
        function updateInfoText() { let text = ""; const activeAssise = assises.find(a => a.id === activeAssiseId); const assiseInfo = activeAssise ? ` | Assise: ${activeAssise.name}` + (activeAssise.height !== null ? ` (${activeAssise.height.toFixed(1)} cm)` : '') : ''; switch(currentTool) { case 'select': text = selectedElement ? `Mode: Sélectionné (ID: ${selectedElement.id})` : 'Mode: Sélection / Navigation'; text += " (Clic/Appui long, Glisser: Orbiter)"; break; case 'add': const effectiveType = getEffectiveElementType(); const addName = effectiveType ? effectiveType.name : "Invalide"; if (addState === 'positioning') text = `Positionnement (${addName}): Ajustez (Flèches/PgUpDn), Rotation (QE), puis Placer (✅/Entrée) ou Annuler (❌/Échap)`; else text = `Mode: Ajouter (${addName}) - Cliquez/Tapez pour positionner`; text += assiseInfo; break; case 'move': if (moveState === 'moving') { const moveName = getElementTypeForSelected()?.name || `ID ${selectedElement?.id}`; text = `Déplacement (${moveName}): Ajustez (Flèches/PgUpDn), Rotation (QE), puis Confirmer (✅/Entrée) ou Annuler (❌/Échap)`; text += assiseInfo; } else text = selectedElement ? `Mode: Déplacer (Prêt pour ID: ${selectedElement.id})` : 'Mode: Déplacer (Sélectionnez d\'abord)'; break; case 'duplicate': const dupName = getElementTypeForSelected()?.name || `ID ${selectedElement?.id}`; text = selectedElement ? `Mode: Dupliquer (${dupName}) - Cliquez/Tapez pour placer copie` : 'Mode: Dupliquer (Sélectionnez d\'abord)'; text += assiseInfo; break; default: text = `Mode: ${currentTool}`; } if (btnExportPdf && btnExportPdf.disabled) text += " | Exportation PDF en cours..."; infoText.textContent = text; }

        // --- Animation Loop ---
        function animate() {
            requestAnimationFrame(animate);
            if (controls.enabled) {
                controls.update();
            }
            renderer.render(scene, camera);
        }

        // --- Initialization ---
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', init);
        } else {
            init();
        }

    </script>
</body>
</html>
