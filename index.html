<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MurSimulateur3D</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <style>
        /* --- GENERAL STYLES --- */
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            margin: 0;
            display: flex;
            flex-direction: column;
            height: 100vh;
            overflow: hidden; 
            font-size: 13px; 
            background-color: #E5E5E5; 
        }

        button, select, input[type="text"], input[type="number"] {
            font-size: inherit;
            border-radius: 3px; 
            border: 1px solid #B0B0B0; 
            padding: 5px 8px;
            background-color: #F5F5F5; 
            color: #333333; 
            margin: 2px;
        }
        button:hover {
            background-color: #E0E0E0; 
            border-color: #909090;
        }
        select {
            padding: 4px 6px;
        }

        /* --- HEADER & MENUS --- */
        header {
            background-color: #F5F5F5; 
            color: #333333; 
            padding: 0;
            display: flex;
            flex-direction: column;
            z-index: 1000; 
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
            border-bottom: 1px solid #D1D1D1;
        }

        #main-menu {
            display: flex;
            background-color: #EAEAEA; 
        }

        .menu-item {
            position: relative;
            padding: 8px 15px; 
            cursor: pointer;
            transition: background-color 0.2s ease;
            border-right: 1px solid #D1D1D1;
        }
        .menu-item:hover {
            background-color: #D5D5D5; 
        }
        .dropdown-content {
            display: none;
            position: absolute;
            background-color: #F5F5F5; 
            min-width: 200px;
            box-shadow: 0px 4px 8px 0px rgba(0,0,0,0.15);
            z-index: 1;
            left: 0;
            top: 100%;
            border: 1px solid #C0C0C0;
            border-top: none;
        }
        .dropdown-content a {
            color: #333333; 
            padding: 10px 15px;
            text-decoration: none;
            display: block;
            transition: background-color 0.2s ease;
        }
        .dropdown-content a:hover {
            background-color: #E0E0E0; 
        }
        .menu-item:hover .dropdown-content {
            display: block;
        }

        /* --- TOOLBAR --- */
        #toolbar {
            display: flex;
            align-items: center;
            padding: 5px 10px; 
            flex-wrap: wrap;
            background-color: #F0F0F0; 
        }
        #toolbar button, #toolbar select {
            margin-right: 5px;
            margin-bottom: 3px; 
            padding: 6px 10px; 
            background-color: #EFEFEF;
            border: 1px solid #BDBDBD;
            color: #424242;
        }
        #toolbar button:hover, #toolbar select:hover {
            background-color: #DADADA;
            border-color: #A0A0A0;
        }
        #toolbar input[type="number"], #toolbar input[type="text"] {
            margin-right: 5px;
            margin-bottom: 3px;
            padding: 6px;
            border: 1px solid #BDBDBD;
            background-color: #fff;
        }
        #toolbar input[type="number"] {
            width: 65px;
        }
        #custom-dims-container input, #vide-depth-container input {
            margin-left: 5px;
        }
        #vide-depth-container label { 
            margin-left: 8px;
            color: #424242; 
        }

        .tool-active {
            background-color: #C5E1A5 !important; 
            color: #333333 !important;
            border-color: #A5D6A7 !important; 
        }

        /* --- HELP BAR --- */
        #help-bar {
            background-color: #FFFFFF; 
            color: #555555; 
            padding: 6px 12px;
            font-size: 0.8em;
            text-align: left; 
            border-bottom: 1px solid #D0D0D0;
            height: 20px; 
            line-height: 20px; 
        }


        /* --- MAIN LAYOUT & SIDEBARS --- */
        main {
            display: flex;
            flex-grow: 1; 
            overflow: hidden; 
        }

        #left-sidebar, #right-sidebar {
            box-sizing: border-box; 
            width: 240px; 
            background-color: #F0F0F0; 
            padding: 10px; 
            flex-shrink: 0; 
            overflow-y: auto; 
            z-index: 900; 
            border-color: #C0C0C0; 
        }
        #left-sidebar { 
            border-right: 1px solid #D1D1D1; 
        }
        #right-sidebar { 
            border-left: 1px solid #D1D1D1; 
        }
        
        .sidebar-content h3 {
            margin-top: 5px;
            font-size: 1.0em; 
            color: #424242; 
            border-bottom: 1px solid #BDBDBD; 
            padding-bottom: 6px;
            margin-bottom: 10px;
            font-weight: 600;
        }
        .sidebar-content label {
            display: block;
            margin-top: 10px;
            margin-bottom: 3px;
            font-size: 0.9em;
            font-weight: normal; 
            color: #555555; 
        }
        .sidebar-content input[type="text"],
        .sidebar-content textarea,
        .sidebar-content select {
            width: calc(100% - 16px); 
            padding: 6px;
            margin-bottom: 10px;
            border: 1px solid #BDBDBD; 
            border-radius: 3px;
            box-sizing: border-box;
        }
        .sidebar-content button {
            padding: 8px 12px;
            background-color: #E0E0E0; 
            color: #424242;
            border: 1px solid #B0B0B0;
            margin-top: 8px;
            width: 100%;
        }
        .sidebar-content button:hover {
            background-color: #D0D0D0; 
            border-color: #9E9E9E;
        }
        #remove-current-seating {
            background-color: #EF9A9A; 
        }
        #remove-current-seating:hover {
            background-color: #E57373; 
        }

        /* --- COLOR PALETTE --- */
        #color-palette-container {
            margin-top: 15px;
        }
        .color-palette {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(30px, 1fr));
            gap: 5px;
        }
        .color-swatch {
            width: 30px;
            height: 30px;
            border: 1px solid #B0B0B0;
            border-radius: 3px;
            cursor: pointer;
            transition: transform 0.1s ease, border-color 0.1s ease;
        }
        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #777;
        }
        .color-swatch.active-color-swatch {
            border: 2px solid #3498db; /* Highlight for active color */
            transform: scale(1.05);
        }


        /* --- VIEWPORT & CANVAS --- */
        #viewport-container {
            flex-grow: 1;
            position: relative; 
            display: flex; 
            overflow: hidden; 
        }
        #threejs-canvas { 
            width: 100%;
            height: 100%;
            display: block;
        }
        #watermark {
            position: absolute;
            bottom: 10px; 
            left: 10px;  
            color: rgba(0, 0, 0, 0.6); 
            font-size: 0.75em; 
            pointer-events: none; 
            text-shadow: 0px 0px 1px rgba(255,255,255,0.5);
            line-height: 1.3;
        }

        /* --- DPAD CONTROLS --- */
        #dpad-controls {
            position: absolute;
            bottom: 15px;
            right: 15px;
            background-color: rgba(220, 220, 220, 0.75); 
            padding: 8px;
            border-radius: 6px;
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            grid-template-rows: repeat(3, 1fr); 
            gap: 4px;
            z-index: 100;
            touch-action: none; 
            border: 1px solid rgba(0,0,0,0.1);
        }
        #dpad-controls button {
            background-color: #F0F0F0; 
            color: #555555;
            border: 1px solid #B0B0B0; 
            font-size: 1.5em; 
            width: 45px; 
            height: 45px;
            border-radius: 4px;
        }
        #dpad-controls button:hover {
            background-color: #E0E0E0;
            border-color: #9E9E9E;
        }
        #dpad-controls button:active {
            background-color: #D0D0D0; 
            transform: scale(0.95);
        }

        #dpad-confirm    { background-color: #A5D6A7; } 
        #dpad-confirm:hover { background-color: #81C784; } 

        /* Positionnement du DPad */
        #dpad-level-up   { grid-column: 1; grid-row: 1; }
        #dpad-up         { grid-column: 2; grid-row: 1; }
        #dpad-rot-left   { grid-column: 3; grid-row: 1; }

        #dpad-left       { grid-column: 1; grid-row: 2; }
        #dpad-confirm    { grid-column: 2; grid-row: 2; } 
        #dpad-right      { grid-column: 3; grid-row: 2; }

        #dpad-level-down { grid-column: 1; grid-row: 3; }
        #dpad-down       { grid-column: 2; grid-row: 3; }
        #dpad-rot-right  { grid-column: 3; grid-row: 3; }


        /* --- ELEMENT COUNTER TABLE --- */
        #element-counter {
            width: 100%;
            border-collapse: collapse;
            margin-top: 15px;
            font-size: 0.9em;
        }
        #element-counter th, #element-counter td {
            border: 1px solid #D0D0D0; 
            padding: 6px 8px;
            text-align: left;
        }
        #element-counter th {
            background-color: #E8E8E8; 
            color: #424242; 
            font-weight: 600;
        }
        #element-counter tr:nth-child(even) {
            background-color: #F5F5F5; 
        }

        /* --- MISC --- */
        .highlighted { 
            outline: 3px solid #f1c40f; 
            outline-offset: -1px;
        }
        .crosshair-cursor {
            cursor: crosshair;
        }
        .default-cursor {
            cursor: default;
        }
        .move-cursor {
            cursor: move;
        }
    </style>
</head>
<body>
    <header>
        <nav id="main-menu">
            <div class="menu-item">
                Fichier
                <div class="dropdown-content">
                    <a href="#" id="new-file">Nouveau</a>
                    <a href="#" id="open-file">Ouvrir</a>
                    <a href="#" id="save-file">Enregistrer</a>
                    <a href="#" id="export-pdf">Exporter en PDF</a>
                </div>
            </div>
            <div class="menu-item">
                Edition
                <div class="dropdown-content">
                    <a href="#" id="edit-selection">Modifier Sélection</a>
                </div>
            </div>
            <div class="menu-item">
                Style
                <div class="dropdown-content">
                    <a href="#" id="style-white">Éléments en Blanc</a>
                    <a href="#" id="style-color">Éléments en Couleur</a>
                    <a href="#" id="toggle-shadows">Activer/Désactiver Ombres</a>
                </div>
            </div>
            <div class="menu-item">
                Aide
                <div class="dropdown-content">
                    <a href="#" id="about-app">À Propos</a>
                    <a href="#" id="help-guide">Aide</a>
                </div>
            </div>
        </nav>
        <div id="toolbar">
            <button id="select-tool" title="Sélectionner (S)">Sél.</button>
            <button id="add-tool" title="Ajouter (A)">Ajouter</button>
            <button id="move-tool" title="Déplacer (M)">Dépl.</button>
            <button id="duplicate-tool" title="Dupliquer (Maj+D)">Dupl.</button>
            <button id="rotate-tool" title="Pivoter (R)">Piv.</button>
            <button id="delete-tool" title="Supprimer (Suppr)">Suppr.</button>
            <select id="element-type-selector">
                <optgroup label="Briques">
                    <option value="brique_m50" data-dims="0.19,0.05,0.09">Brique M50 (19x5x9)</option>
                    <option value="brique_m57" data-dims="0.19,0.057,0.09">Brique M57 (19x5.7x9)</option>
                    <option value="brique_m65" data-dims="0.19,0.065,0.09">Brique M65 (19x6.5x9)</option>
                    <option value="brique_m90" data-dims="0.19,0.09,0.09">Brique M90 (19x9x9)</option>
                    <option value="brique_wf" data-dims="0.21,0.05,0.10">Brique WF (21x5x10)</option>
                    <option value="brique_wfd" data-dims="0.21,0.065,0.10">Brique WFD (21x6.5x10)</option>
                </optgroup>
                <optgroup label="Blocs">
                    <option value="bloc_b9" data-dims="0.39,0.19,0.09">Bloc B9 (39x19x9)</option>
                    <option value="bloc_b14" data-dims="0.39,0.19,0.14">Bloc B14 (39x19x14)</option>
                    <option value="bloc_b19" data-dims="0.39,0.19,0.19">Bloc B19 (39x19x19)</option>
                    <option value="bloc_b29" data-dims="0.39,0.19,0.29">Bloc B29 (39x19x29)</option>
                </optgroup>
                <optgroup label="Linteaux">
                    <option value="linteau_l120_14" data-dims="1.20,0.19,0.14">Linteau L120 (120x19x14)</option>
                    <option value="linteau_l140_14" data-dims="1.40,0.19,0.14">Linteau L140 (140x19x14)</option>
                    <option value="linteau_l160_14" data-dims="1.60,0.19,0.14">Linteau L160 (160x19x14)</option>
                    <option value="linteau_l180_14" data-dims="1.80,0.19,0.14">Linteau L180 (180x19x14)</option>
                    <option value="linteau_l200_14" data-dims="2.00,0.19,0.14">Linteau L200 (200x19x14)</option>
                </optgroup>
                <optgroup label="Isolants">
                    <option value="isolant_pur5" data-dims="1.20,0.60,0.05">Isolant PUR5 (120x60x5)</option>
                    <option value="isolant_pur6" data-dims="1.20,0.60,0.06">Isolant PUR6 (120x60x6)</option>
                    <option value="isolant_pur7" data-dims="1.20,0.60,0.07">Isolant PUR7 (120x60x7)</option>
                </optgroup>
                <optgroup label="Autres">
                    <option value="vide" data-dims="0.40,0.19,0.01" data-depth-range="0.01,0.05">Vide (40x19x1-5)</option>
                    <option value="profil" data-dims="2.50,0.065,0.065">Profil (250x6.5x6.5)</option>
                </optgroup>
                <optgroup label="Personnalisé">
                    <option value="custom">Élément Personnalisé</option>
                </optgroup>
            </select>
            <div id="custom-dims-container" style="display: none; align-items: center;">
                <input type="text" id="custom-name" placeholder="Nom" style="width:100px;">
                <input type="number" id="custom-width" placeholder="L (m)" step="0.01" min="0.01">
                <input type="number" id="custom-height" placeholder="H (m)" step="0.01" min="0.01">
                <input type="number" id="custom-depth" placeholder="P (m)" step="0.01" min="0.01">
            </div>
             <div id="vide-depth-container" style="display: none; align-items: center;">
                <label for="vide-depth" style="color:white; margin-right:5px;">Prof. Vide (cm):</label>
                <input type="number" id="vide-depth" value="1" min="1" max="5" step="0.1">
            </div>
        </div>
        <div id="help-bar">
            Bienvenue ! Utilisez la barre d'outils pour commencer.
        </div>
    </header>

    <main>
        <aside id="left-sidebar">
            <div class="sidebar-content">
                 <h3>Palette de Couleurs</h3>
                 <div id="color-palette-container">
                    </div>
                 <h3>Outils Supplémentaires</h3>
                 <p>(Autres outils à venir)</p>
                 <p>Navigation : Clic gauche + glisser pour orbiter, Clic droit + glisser pour translater, Molette pour zoomer.</p>
            </div>
        </aside>

        <div id="viewport-container">
            <div id="threejs-canvas"></div> 
            <div id="watermark">MurSimulateur3D by J.BROHEZ - Copyright © 2025 - v1.0.1</div>
            <div id="dpad-controls">
                <button id="dpad-level-up" title="Monter Élément/Assise (PageUp)">⇞</button>
                <button id="dpad-up" title="Avancer (W ou ↑)">▲</button>
                <button id="dpad-rot-left" title="Rotation Gauche (Q)">↺</button>
                <button id="dpad-left" title="Gauche (A ou ←)">◀</button>
                <button id="dpad-confirm" title="Confirmer (Entrée)">OK</button>
                <button id="dpad-right" title="Droite (D ou →)">▶</button>
                <button id="dpad-level-down" title="Descendre Élément/Assise (PageDown)">⇟</button>
                <button id="dpad-down" title="Reculer (S ou ↓)">▼</button>
                <button id="dpad-rot-right" title="Rotation Droite (E)">↻</button>
            </div>
        </div>

        <aside id="right-sidebar">
            <div class="sidebar-content">
                <h3>Métadonnées</h3>
                <label for="project-title">Titre de l'ouvrage:</label>
                <input type="text" id="project-title" name="project-title">
                <label for="designer-name">Dessinateur:</label>
                <input type="text" id="designer-name" name="designer-name">
                <label for="operating-mode">Mode opératoire:</label>
                <textarea id="operating-mode" name="operating-mode" rows="3"></textarea>

                <h3>Gestion des Assises</h3>
                <label for="seating-level-selector">Assise Actuelle:</label>
                <select id="seating-level-selector">
                    <option value="0" data-y="0">Assise 0 (Niveau 0.00m)</option>
                </select>
                <button id="add-new-seating">Créer Nouvelle Assise</button>
                <button id="remove-current-seating" title="Supprimer Assise Actuelle (si vide)">Suppr. Assise</button>

                <h3>Compteur d'Éléments</h3>
                <table id="element-counter">
                    <thead>
                        <tr>
                            <th>Type</th>
                            <th>Quantité</th>
                        </tr>
                    </thead>
                    <tbody>
                        </tbody>
                </table>
            </div>
        </aside>
    </main>
    <script>
        document.addEventListener('DOMContentLoaded', () => {
            // --- THREE.JS SETUP ---
            let scene, camera, renderer, controls, raycaster, mousePointer; 
            let plane; 
            let objects = []; 
            let ghostElement = null; 
            let selectedObject = null;
            const initialCameraPosition = new THREE.Vector3(0.8, 0.7, 1.5); 
            const initialCameraLookAt = new THREE.Vector3(0, 0.5, 0);


            // --- APPLICATION STATE ---
            let currentTool = 'select'; 
            const snapGridSize = 0.01; 
            let currentSeatingIndex = 0;
            let seatingLevels = { 0: { y: 0, name: "Assise 0 (Niveau 0.00m)" } }; 
            const defaultSeatingHeightIncrement = 0.20; 
            let isGhostFixed = false; 

            const elementColors = {
                brique: 0xCD5C5C,  
                bloc: 0x87CEEB,    
                linteau: 0x778899, 
                isolant: 0xFFE4B5, 
                vide: 0xADD8E6,    
                profil: 0xBDB76B,  
                custom: 0x98FB98,  
                default: 0xBEBEBE  
            };
            let useWhiteElements = false;
            let shadowsEnabled = true; 

            // --- COLOR PALETTE ---
            const colorPalette = [
                0xFF0000, 0x00FF00, 0x0000FF, 0xFFFF00, 0xFF00FF, 0x00FFFF, 
                0x800080, 0xFFA500, 0xA52A2A, 0x808080, 0x000000, 0xFFFFFF,
                0xCD5C5C, 0x87CEEB, 0x778899, 0xFFE4B5, 0xBDB76B, 0x98FB98 
            ];
            let currentActiveColor = null;
            let activeSwatchElement = null;


            // --- DOM ELEMENTS ---
            const canvasContainer = document.getElementById('threejs-canvas'); 
            const viewportContainer = document.getElementById('viewport-container'); 
            const elementTypeSelector = document.getElementById('element-type-selector');
            const customDimsContainer = document.getElementById('custom-dims-container');
            const customNameInput = document.getElementById('custom-name');
            const customWidthInput = document.getElementById('custom-width');
            const customHeightInput = document.getElementById('custom-height');
            const customDepthInput = document.getElementById('custom-depth');
            const videDepthContainer = document.getElementById('vide-depth-container');
            const videDepthInput = document.getElementById('vide-depth');
            const helpBar = document.getElementById('help-bar');
            const colorPaletteContainer = document.getElementById('color-palette-container');


            const toolButtons = {
                select: document.getElementById('select-tool'),
                add: document.getElementById('add-tool'),
                move: document.getElementById('move-tool'),
                duplicate: document.getElementById('duplicate-tool'),
                rotate: document.getElementById('rotate-tool'),
                delete: document.getElementById('delete-tool')
            };

            const dpad = {
                up: document.getElementById('dpad-up'),
                down: document.getElementById('dpad-down'),
                left: document.getElementById('dpad-left'),
                right: document.getElementById('dpad-right'),
                confirm: document.getElementById('dpad-confirm'),
                rotLeft: document.getElementById('dpad-rot-left'),
                rotRight: document.getElementById('dpad-rot-right'),
                levelUp: document.getElementById('dpad-level-up'),
                levelDown: document.getElementById('dpad-level-down')
            };

            const seatingLevelSelector = document.getElementById('seating-level-selector');
            const addNewSeatingBtn = document.getElementById('add-new-seating');
            const removeCurrentSeatingBtn = document.getElementById('remove-current-seating');
            const elementCounterTableBody = document.getElementById('element-counter').getElementsByTagName('tbody')[0];
            
            const leftSidebar = document.getElementById('left-sidebar');
            const rightSidebar = document.getElementById('right-sidebar');

            const newFileBtn = document.getElementById('new-file');
            const openFileBtn = document.getElementById('open-file');
            const saveFileBtn = document.getElementById('save-file');
            const exportPdfBtn = document.getElementById('export-pdf');
            const editSelectionBtn = document.getElementById('edit-selection'); 
            const styleWhiteBtn = document.getElementById('style-white');
            const styleColorBtn = document.getElementById('style-color');
            const toggleShadowsBtn = document.getElementById('toggle-shadows');
            const aboutAppBtn = document.getElementById('about-app');
            const helpGuideBtn = document.getElementById('help-guide');

            // --- INITIALIZATION ---
            function initThreeJS() {
                scene = new THREE.Scene();
                scene.background = new THREE.Color(0xADD8E6); // Sky blue

                camera = new THREE.PerspectiveCamera(50, viewportContainer.clientWidth / viewportContainer.clientHeight, 0.1, 1000);
                camera.position.copy(initialCameraPosition);
                camera.lookAt(initialCameraLookAt);

                renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true }); 
                renderer.setSize(viewportContainer.clientWidth, viewportContainer.clientHeight);
                renderer.shadowMap.enabled = shadowsEnabled; 
                renderer.shadowMap.type = THREE.PCFSoftShadowMap;
                canvasContainer.appendChild(renderer.domElement); 

                controls = new THREE.OrbitControls(camera, renderer.domElement);
                controls.mouseButtons = {
                    LEFT: THREE.MOUSE.ROTATE,   
                    MIDDLE: THREE.MOUSE.PAN,    
                    RIGHT: THREE.MOUSE.ROTATE   
                };
                
                controls.enableDamping = true;
                controls.dampingFactor = 0.05;
                controls.screenSpacePanning = true; 
                controls.minDistance = 0.1; 
                controls.maxDistance = 150; 
                controls.maxPolarAngle = Math.PI / 2 - 0.01; 
                controls.target.copy(initialCameraLookAt);
                controls.update();

                const ambientLight = new THREE.AmbientLight(0xffffff, 0.8); 
                scene.add(ambientLight);

                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.0); 
                directionalLight.position.set(15, 20, 10); 
                directionalLight.castShadow = shadowsEnabled; 
                directionalLight.shadow.mapSize.width = 2048;
                directionalLight.shadow.mapSize.height = 2048;
                directionalLight.shadow.camera.near = 0.5;
                directionalLight.shadow.camera.far = 60; 
                directionalLight.shadow.camera.left = -20;
                directionalLight.shadow.camera.right = 20;
                directionalLight.shadow.camera.top = 20;
                directionalLight.shadow.camera.bottom = -20;
                scene.add(directionalLight);
                
                const planeGeometry = new THREE.PlaneGeometry(100, 100); 
                const planeMaterial = new THREE.MeshStandardMaterial({ color: 0xCCCCCC, side: THREE.DoubleSide, roughness: 0.9, metalness: 0.1 }); 
                plane = new THREE.Mesh(planeGeometry, planeMaterial);
                plane.rotation.x = -Math.PI / 2;
                plane.receiveShadow = true; 
                plane.name = "GroundPlane";
                scene.add(plane);

                const gridHelper = new THREE.GridHelper(100, 100, 0xaaaaaa, 0xcccccc); 
                gridHelper.name = "GridHelper"; 
                gridHelper.visible = false; 
                scene.add(gridHelper);

                raycaster = new THREE.Raycaster();
                mousePointer = new THREE.Vector2();

                window.addEventListener('resize', onWindowResize, false);
                viewportContainer.addEventListener('pointerdown', onViewportPointerDown, false); 
                viewportContainer.addEventListener('pointermove', onViewportPointerMove, false);
                document.addEventListener('keydown', onDocumentKeyDown, false);

                setupUIEventListeners();
                createColorPalette(); 
                updateActiveToolButton();
                updateSeatingSelector();
                updateCursorStyle();
                updateHelpBar(); 

                animate();
            }

            // --- UI EVENT LISTENERS ---
            function setupUIEventListeners() {
                elementTypeSelector.addEventListener('change', () => {
                    customDimsContainer.style.display = elementTypeSelector.value === 'custom' ? 'inline-flex' : 'none';
                    videDepthContainer.style.display = elementTypeSelector.value === 'vide' ? 'inline-flex' : 'none';
                    if (currentTool === 'add') {
                        removeGhostElement(); 
                        isGhostFixed = false; 
                        createGhostElement(); 
                    }
                });
                videDepthInput.addEventListener('change', () => {
                    if (ghostElement && ghostElement.userData.type === 'vide') {
                        const newDepth = parseFloat(videDepthInput.value) / 100; 
                        const oldHeight = ghostElement.userData.height;
                        const oldWidth = ghostElement.userData.width;
                        ghostElement.geometry.dispose(); 
                        ghostElement.geometry = new THREE.BoxGeometry(oldWidth, oldHeight, newDepth);
                        ghostElement.userData.depth = newDepth;
                    }
                });

                Object.keys(toolButtons).forEach(toolName => {
                    toolButtons[toolName].addEventListener('click', () => setCurrentTool(toolName));
                });

                dpad.up.addEventListener('click', (event) => { event.stopPropagation(); moveGhostOrSelected('forward', event); });
                dpad.down.addEventListener('click', (event) => { event.stopPropagation(); moveGhostOrSelected('backward', event); });
                dpad.left.addEventListener('click', (event) => { event.stopPropagation(); moveGhostOrSelected('left', event); });
                dpad.right.addEventListener('click', (event) => { event.stopPropagation(); moveGhostOrSelected('right', event); });
                dpad.confirm.addEventListener('click', (event) => { event.stopPropagation(); confirmPlacement(); }); 
                dpad.rotLeft.addEventListener('click', (event) => { event.stopPropagation(); rotateGhostOrSelected('left', event); });
                dpad.rotRight.addEventListener('click', (event) => { event.stopPropagation(); rotateGhostOrSelected('right', event); });
                dpad.levelUp.addEventListener('click', (event) => { event.stopPropagation(); moveGhostOrSelected('up', event); });
                dpad.levelDown.addEventListener('click', (event) => { event.stopPropagation(); moveGhostOrSelected('down', event); });


                addNewSeatingBtn.addEventListener('click', createNewSeatingLevel);
                removeCurrentSeatingBtn.addEventListener('click', removeCurrentSeatingLevel);
                seatingLevelSelector.addEventListener('change', (e) => {
                    currentSeatingIndex = parseInt(e.target.value);
                    if (ghostElement && !isGhostFixed) { 
                        ghostElement.position.y = seatingLevels[currentSeatingIndex].y + ghostElement.userData.height / 2;
                    } else if (selectedObject && currentTool === 'move') {
                        selectedObject.position.y = seatingLevels[currentSeatingIndex].y + selectedObject.geometry.parameters.height / 2;
                    }
                });

                newFileBtn.addEventListener('click', handleNewFile);
                openFileBtn.addEventListener('click', handleOpenFile);
                saveFileBtn.addEventListener('click', handleSaveFile);
                exportPdfBtn.addEventListener('click', handleExportPDF);
                editSelectionBtn.addEventListener('click', handleEditSelection); 
                styleWhiteBtn.addEventListener('click', () => setElementStyle(true));
                styleColorBtn.addEventListener('click', () => setElementStyle(false));
                toggleShadowsBtn.addEventListener('click', toggleAllShadows);
                aboutAppBtn.addEventListener('click', () => alert('MurSimulateur3D\nVersion 1.0.1\nDéveloppé par J.BROHEZ avec Three.js.\nCopyright © 2025 J.BROHEZ\n\nDimensions des éléments: Longueur x Hauteur x Profondeur (Épaisseur du mur)'));
                helpGuideBtn.addEventListener('click', () => alert('Aide :\n- Barre d\'outils : Sélectionner un outil puis interagir.\n- Ajout : Cliquer sur la grille pour fixer la position initiale du fantôme, ajuster avec le DPad, confirmer avec OK.\n- DPad : Flèches pour déplacer, ↺/↻ pour rotation, ⇞/⇟ pour monter/descendre. Maintenir Maj pour un pas plus grand.\n- Sélection : Cliquer sur un objet pour le sélectionner. Si une couleur est active (palette), elle sera appliquée.\n- Navigation : Clic gauche/droit + glisser = Orbite | Clic milieu + glisser = Pan | Molette = Zoom.\n- Raccourcis : S (Select), A (Add), M (Move), Maj+D (Duplicate), R (Rotate), Suppr (Delete), Entrée (Confirm DPad).\n Ctrl+S (Sauvegarder), Ctrl+O (Ouvrir).\n- Barres latérales : Cliquer sur < ou > pour les replier/déplier.'));
            }
            
            function updateCursorStyle() {
                viewportContainer.classList.remove('crosshair-cursor', 'default-cursor', 'move-cursor');
                if (currentTool === 'select' && currentActiveColor !== null) {
                    viewportContainer.style.cursor = 'copy'; // Or a custom paint bucket cursor
                } else {
                    viewportContainer.style.cursor = ''; // Reset to default or tool-specific
                    switch (currentTool) {
                        case 'add':
                        case 'select':
                            viewportContainer.classList.add('crosshair-cursor');
                            break;
                        case 'move':
                             viewportContainer.classList.add('move-cursor');
                            break;
                        default:
                            viewportContainer.classList.add('default-cursor');
                            break;
                    }
                }
            }
            
            function updateHelpBar() {
                let helpText = "Navigation: Clic Gauche/Droit + Glisser = Orbite | Clic Milieu + Glisser = Pan | Molette = Zoom.";
                 if (currentActiveColor !== null && currentTool === 'select') {
                    helpText = "Mode PEINTURE: Cliquez sur un élément pour appliquer la couleur sélectionnée. Désactivez la couleur (palette/Échap) pour sélectionner.";
                } else {
                    switch (currentTool) {
                        case 'add':
                            helpText = isGhostFixed ? 
                                       "Mode AJOUT: Ajustez avec le DPad, puis confirmez avec 'OK'. (Échap pour annuler/repositionner). Clic Droit/Molette pour naviguer." :
                                       "Mode AJOUT: Cliquez sur la grille pour placer l'élément fantôme.";
                            break;
                        case 'select':
                            helpText = "Mode SÉLECTION: Cliquez sur un élément pour le sélectionner. Choisissez une couleur dans la palette pour peindre.";
                            break;
                        case 'move':
                            helpText = selectedObject ? "Mode DÉPLACER: Utilisez le DPad pour déplacer. Confirmez avec 'OK'." : "Mode DÉPLACER: Cliquez sur un élément pour le sélectionner.";
                            break;
                        case 'rotate':
                            helpText = selectedObject ? "Mode PIVOTER: Utilisez le DPad (↺, ↻). Confirmez avec 'OK'." : "Mode PIVOTER: Cliquez sur un élément pour le sélectionner.";
                            break;
                        case 'duplicate':
                            helpText = "Mode DUPLIQUER: Cliquez sur un élément pour le dupliquer.";
                            break;
                        case 'delete':
                            helpText = "Mode SUPPRIMER: Cliquez sur un élément pour le supprimer.";
                            break;
                    }
                }
                helpBar.textContent = helpText;
            }


            // --- TOOL MANAGEMENT ---
            function setCurrentTool(tool) {
                currentTool = tool;
                updateActiveToolButton();
                
                if (tool !== 'select' && currentActiveColor !== null) { // Deactivate color if switching away from select tool
                    if (activeSwatchElement) activeSwatchElement.classList.remove('active-color-swatch');
                    currentActiveColor = null;
                    activeSwatchElement = null;
                }
                
                updateCursorStyle(); // Update cursor after potential color deactivation
                updateHelpBar(); 

                if (tool === 'add' || tool === 'select') {
                    deselectObject(); // This also re-enables controls.enableRotate if not in add mode
                }

                if (tool === 'add') {
                    if (!ghostElement) createGhostElement();
                    if (ghostElement) ghostElement.visible = true;
                    controls.enabled = false; 
                    controls.enableRotate = false; 
                    isGhostFixed = false; 
                } else {
                    removeGhostElement(); 
                    if ((tool === 'move' || tool === 'rotate') && selectedObject) {
                        controls.enabled = false; 
                    } else {
                        controls.enabled = true;  
                    }
                    controls.enableRotate = true; 
                    isGhostFixed = false;
                }
                if (controls) controls.update(); 
            }


            function updateActiveToolButton() {
                Object.values(toolButtons).forEach(btn => btn.classList.remove('tool-active'));
                if (toolButtons[currentTool]) {
                    toolButtons[currentTool].classList.add('tool-active');
                }
            }

            // --- COLOR PALETTE ---
            function createColorPalette() {
                const paletteDiv = document.createElement('div');
                paletteDiv.className = 'color-palette';
                colorPalette.forEach(colorHex => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = '#' + colorHex.toString(16).padStart(6, '0');
                    swatch.dataset.color = colorHex; // Store as number
                    swatch.addEventListener('click', (event) => {
                        event.stopPropagation(); // Prevent click from bubbling to viewport
                        if (activeSwatchElement === swatch) { // Clicked the active swatch again
                            currentActiveColor = null;
                            activeSwatchElement.classList.remove('active-color-swatch');
                            activeSwatchElement = null;
                        } else {
                            if (activeSwatchElement) {
                                activeSwatchElement.classList.remove('active-color-swatch');
                            }
                            currentActiveColor = parseInt(swatch.dataset.color); // Store as number
                            activeSwatchElement = swatch;
                            activeSwatchElement.classList.add('active-color-swatch');
                            if (currentTool !== 'select') { // Switch to select tool if a color is chosen
                                setCurrentTool('select');
                            }
                        }
                        updateCursorStyle();
                        updateHelpBar();
                    });
                    paletteDiv.appendChild(swatch);
                });
                colorPaletteContainer.appendChild(paletteDiv);
            }


            // --- ELEMENT CREATION & MANAGEMENT ---
            function getElementProperties() {
                const selectedOption = elementTypeSelector.options[elementTypeSelector.selectedIndex];
                const typeKey = selectedOption.value; 
                const baseType = typeKey.split('_')[0]; 
                let dims, name, specificDepth;

                if (typeKey === 'custom') {
                    name = customNameInput.value.trim() || 'Perso';
                    const w = parseFloat(customWidthInput.value) || 0.2;
                    const h = parseFloat(customHeightInput.value) || 0.1;
                    const d = parseFloat(customDepthInput.value) || 0.1;
                    dims = [w, h, d];
                } else {
                    name = selectedOption.textContent.split(' (')[0];
                    dims = selectedOption.dataset.dims.split(',').map(Number);
                    if (typeKey === 'vide') {
                        specificDepth = parseFloat(videDepthInput.value) / 100; 
                        dims[2] = specificDepth; 
                    }
                }
                return {
                    type: typeKey, 
                    baseType: baseType, 
                    name: name,
                    width: dims[0],  
                    height: dims[1], 
                    depth: dims[2]   
                };
            }

            function createGhostElement() {
                if (ghostElement) scene.remove(ghostElement);

                const props = getElementProperties();
                const geometry = new THREE.BoxGeometry(props.width, props.height, props.depth);
                const material = new THREE.MeshBasicMaterial({
                    color: 0x00cc00, 
                    opacity: 0.5,
                    transparent: true,
                    wireframe: true,
                    depthTest: false 
                });
                ghostElement = new THREE.Mesh(geometry, material);
                ghostElement.userData = { ...props, isGhost: true }; 
                ghostElement.position.set(0, seatingLevels[currentSeatingIndex].y + props.height / 2, 0); 
                ghostElement.visible = (currentTool === 'add'); 
                scene.add(ghostElement);
            }

            function removeGhostElement() {
                if (ghostElement) {
                    scene.remove(ghostElement);
                    if (ghostElement.geometry) ghostElement.geometry.dispose();
                    if (ghostElement.material) ghostElement.material.dispose();
                    ghostElement = null;
                }
                 isGhostFixed = false; 
            }

            function addElementAtPosition(position, rotationY, propsFromGhost) {
                const geometry = new THREE.BoxGeometry(propsFromGhost.width, propsFromGhost.height, propsFromGhost.depth);
                const baseColorHex = elementColors[propsFromGhost.baseType] || elementColors.default;

                const material = new THREE.MeshStandardMaterial({
                    color: useWhiteElements ? 0xffffff : baseColorHex,
                    roughness: 0.7, 
                    metalness: 0.2,
                    transparent: propsFromGhost.baseType === 'vide',
                    opacity: propsFromGhost.baseType === 'vide' ? 0.3 : 1.0, 
                    name: propsFromGhost.name 
                });

                const element = new THREE.Mesh(geometry, material);
                element.castShadow = shadowsEnabled && propsFromGhost.baseType !== 'vide';
                element.receiveShadow = shadowsEnabled && propsFromGhost.baseType !== 'vide';

                element.position.copy(position);
                element.rotation.y = rotationY;
                element.name = propsFromGhost.name; 

                element.userData = {
                    type: propsFromGhost.type,
                    baseType: propsFromGhost.baseType,
                    name: propsFromGhost.name,
                    width: propsFromGhost.width,
                    height: propsFromGhost.height,
                    depth: propsFromGhost.depth,
                    isGhost: false, 
                    id: THREE.MathUtils.generateUUID(),
                    originalColor: baseColorHex, 
                    seatingIndex: currentSeatingIndex 
                };
                
                const edges = new THREE.EdgesGeometry(element.geometry);
                const lineMaterial = new THREE.LineBasicMaterial({ color: 0x000000 }); 
                const lineSegments = new THREE.LineSegments(edges, lineMaterial);
                lineSegments.name = "elementEdges"; 
                element.add(lineSegments); 


                objects.push(element);
                scene.add(element);
                updateElementCounter();
                return element;
            }

            function confirmPlacement() {
                if (currentTool === 'add' && ghostElement && ghostElement.visible) {
                    addElementAtPosition(ghostElement.position.clone(), ghostElement.rotation.y, ghostElement.userData);
                    isGhostFixed = false; 
                    controls.enabled = false; 
                    controls.enableRotate = false; 
                } else if ((currentTool === 'move' || currentTool === 'rotate') && selectedObject) {
                    deselectObject(); 
                    setCurrentTool('select'); 
                }
                updateHelpBar();
            }

            // --- SNAPPING ---
            function snapToGrid(value) {
                return Math.round(value / snapGridSize) * snapGridSize;
            }

            function getSnappedPosition(worldPosition, elementProps) {
                const currentSeatingY = seatingLevels[currentSeatingIndex].y;
                const snappedX = snapToGrid(worldPosition.x);
                const snappedZ = snapToGrid(worldPosition.z);
                const snappedY = currentSeatingY + elementProps.height / 2;
                return new THREE.Vector3(snappedX, snappedY, snappedZ);
            }
            
            // --- DPAD AND MOVEMENT/ROTATION ---
            function moveGhostOrSelected(direction, eventParam) { 
                const target = (currentTool === 'add' && ghostElement && isGhostFixed) ? ghostElement : 
                               ((currentTool === 'move' || currentTool === 'rotate') && selectedObject) ? selectedObject : null;
                if (!target) {
                    return;
                }
 
                const currentEvent = eventParam || window.event; 
                const useShift = currentEvent ? currentEvent.shiftKey : false;

                const moveAmount = snapGridSize * (useShift ? 10 : 5); 
                const heightAdjustAmount = snapGridSize * (useShift ? 5 : 2); 
                
                let moveDirection = new THREE.Vector3();
                if (direction === 'forward' || direction === 'backward' || direction === 'left' || direction === 'right') {
                    const forward = new THREE.Vector3();
                    camera.getWorldDirection(forward);
                    forward.y = 0; 
                    forward.normalize();

                    const rightVec = new THREE.Vector3().crossVectors(camera.up, forward).normalize(); 
                    
                    switch (direction) {
                        case 'forward': moveDirection.copy(forward); break;
                        case 'backward': moveDirection.copy(forward).negate(); break;
                        case 'left': moveDirection.copy(rightVec); break; 
                        case 'right': moveDirection.copy(rightVec).negate(); break; 
                    }
                     target.position.addScaledVector(moveDirection, moveAmount);
                }

                switch (direction) {
                    case 'up':
                        target.position.y += heightAdjustAmount;
                        updateTargetSeatingAfterVerticalMove(target);
                        break;
                    case 'down':
                        target.position.y -= heightAdjustAmount;
                        const targetSeatingIndex = target.userData.seatingIndex !== undefined ? target.userData.seatingIndex : currentSeatingIndex;
                        const currentLevelY = seatingLevels[targetSeatingIndex] ? seatingLevels[targetSeatingIndex].y : 0;
                        const basePosY = currentLevelY + target.userData.height / 2;
                        target.position.y = Math.max(basePosY, target.position.y); 
                        updateTargetSeatingAfterVerticalMove(target);
                        break;
                }

                target.position.x = snapToGrid(target.position.x);
                target.position.z = snapToGrid(target.position.z);
                target.position.y = snapToGrid(target.position.y); 

                if (target === ghostElement && (direction !== 'up' && direction !== 'down')) {
                    if (isGhostFixed) { 
                         target.position.y = seatingLevels[currentSeatingIndex].y + target.userData.height / 2;
                    }
                }
            }
            function updateTargetSeatingAfterVerticalMove(target) {
            }

            function rotateGhostOrSelected(direction, eventParam) { 
                const target = (currentTool === 'add' && ghostElement && isGhostFixed) ? ghostElement : 
                               ((currentTool === 'rotate' || currentTool === 'move') && selectedObject) ? selectedObject : null;
                if (!target) {
                     console.log("[DPAD ROTATE DEBUG] No target for DPad rotation. Tool:", currentTool, "Ghost fixed:", isGhostFixed, "Selected:", selectedObject ? selectedObject.name : 'null');
                    return;
                }

                const currentEvent = eventParam || window.event;
                const useShift = currentEvent ? currentEvent.shiftKey : false;
                const rotAmount = Math.PI / (useShift ? 18 : 36); 
                target.rotation.y += (direction === 'left' ? rotAmount : -rotAmount);
            }

            // --- SELECTION ---
            function selectObject(object) {
                if (selectedObject === object) {
                    return; 
                }
                deselectObject(); 

                selectedObject = object;

                const cond1 = !!selectedObject;
                const cond2 = !!(selectedObject && selectedObject.userData);
                const cond3 = selectedObject && selectedObject.userData ? (selectedObject.userData.isGhost === undefined || selectedObject.userData.isGhost === false) : false;
                
                if (cond1 && cond2 && cond3) { 
                    selectedObject.userData.originalMaterialParams = {
                        color: selectedObject.userData.originalColor || selectedObject.material.color.getHex(),
                        emissive: selectedObject.material.emissive ? selectedObject.material.emissive.getHex() : 0x000000
                    };
                    selectedObject.userData.originalScale = selectedObject.scale.clone();

                    selectedObject.material.color.set(0x00ff00); 
                    selectedObject.material.emissive = new THREE.Color(0x003300); 
                    selectedObject.material.needsUpdate = true;
                    selectedObject.scale.multiplyScalar(1.05); 
                    
                    if (currentTool === 'move' || currentTool === 'rotate') {
                        controls.enabled = false; 
                    } else { 
                        controls.enabled = true; 
                    }
                } else { 
                    selectedObject = null; 
                    if (currentTool !== 'add') { 
                        controls.enabled = true;
                    }
                }
                if(controls) controls.update();
                updateHelpBar();
            }

            function deselectObject() {
                if (selectedObject && selectedObject.userData && selectedObject.userData.isGhost !== true) { 
                    if (selectedObject.userData.originalMaterialParams) {
                        selectedObject.material.color.setHex(selectedObject.userData.originalMaterialParams.color);
                        selectedObject.material.emissive.setHex(selectedObject.userData.originalMaterialParams.emissive);
                        selectedObject.material.needsUpdate = true;
                        delete selectedObject.userData.originalMaterialParams; 
                    }
                    if (selectedObject.userData.originalScale) {
                        selectedObject.scale.copy(selectedObject.userData.originalScale); 
                        delete selectedObject.userData.originalScale; 
                    }
                }
                selectedObject = null; 

                if (currentTool !== 'add') { 
                    controls.enabled = true; 
                    controls.enableRotate = true; 
                    if(controls) controls.update();
                }
                 if (currentTool !== 'add') { 
                    isGhostFixed = false; 
                 }
                 updateHelpBar();
            }

            // --- EVENT HANDLERS (Pointer, Keyboard, Window) ---
            function onWindowResize() {
                const newWidth = viewportContainer.clientWidth;
                const newHeight = viewportContainer.clientHeight;
                camera.aspect = newWidth / newHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(newWidth, newHeight);
            }

            function onViewportPointerMove(event) {
                if (currentTool !== 'add' || !ghostElement || isGhostFixed) return; 

                const rect = viewportContainer.getBoundingClientRect();
                mousePointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mousePointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                raycaster.setFromCamera(mousePointer, camera);
                const intersects = raycaster.intersectObject(plane); 

                if (intersects.length > 0) {
                    const intersectPoint = intersects[0].point;
                    ghostElement.position.copy(getSnappedPosition(intersectPoint, ghostElement.userData));
                    if (!ghostElement.visible) ghostElement.visible = true; 
                }
            }


            function onViewportPointerDown(event) {
                const dpadContainer = document.getElementById('dpad-controls');
                if (dpadContainer && dpadContainer.contains(event.target)) {
                    return; 
                }

                // Process left clicks for object interaction/placement
                if (event.button === 0) { 
                    const rect = viewportContainer.getBoundingClientRect();
                    mousePointer.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                    mousePointer.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;
                                    
                    raycaster.setFromCamera(mousePointer, camera);

                    if (currentTool === 'add') {
                        if (ghostElement && !isGhostFixed) { // First click in add mode
                            isGhostFixed = true; 
                            controls.enabled = true;     // Enable OrbitControls for right-click/wheel
                            controls.enableRotate = true;  // Allow rotation (right-click will orbit)
                            updateHelpBar();
                        }
                    } else if (currentTool === 'select') {
                        const intersectsObjects = raycaster.intersectObjects(objects, false);
                        if (intersectsObjects.length > 0) {
                            const clickedObject = intersectsObjects[0].object;
                            if (clickedObject !== plane && clickedObject.name !== "GridHelper") {
                                if (currentActiveColor !== null) { // Paint mode
                                    clickedObject.userData.originalColor = currentActiveColor;
                                    if (!useWhiteElements) {
                                        clickedObject.material.color.setHex(currentActiveColor);
                                    }
                                    clickedObject.material.needsUpdate = true;
                                    // Don't select the object in the traditional sense, just color it
                                    // If you want to also select it, call selectObject(clickedObject) here
                                    // and potentially remove the deselectObject() from setCurrentTool when a color is active.
                                } else { // Normal selection mode
                                    selectObject(clickedObject);
                                }
                            } else { deselectObject(); }
                        } else { deselectObject(); }
                    } else if (currentTool === 'move' || currentTool === 'duplicate' || currentTool === 'rotate' || currentTool === 'delete') {
                        const intersectsObjects = raycaster.intersectObjects(objects, false); 
                        if (intersectsObjects.length > 0) {
                            const clickedObject = intersectsObjects[0].object;
                            if (clickedObject !== plane && clickedObject.name !== "GridHelper") {
                                if (currentTool === 'move' || currentTool === 'rotate') {
                                    selectObject(clickedObject); 
                                } else if (currentTool === 'duplicate') {
                                    duplicateObject(clickedObject);
                                } else if (currentTool === 'delete') {
                                    deleteObject(clickedObject);
                                }
                            } else { deselectObject(); }
                        } else { deselectObject(); }
                    }
                }
            }

            function onDocumentKeyDown(event) {
                if (document.activeElement && (document.activeElement.tagName === 'INPUT' || document.activeElement.tagName === 'TEXTAREA' || document.activeElement.tagName === 'SELECT')) {
                    if (event.key === 'Escape') document.activeElement.blur(); 
                    return;
                }

                let dpadAction = true; 
                switch (event.key.toLowerCase()) {
                    case 's':
                        if (event.ctrlKey || event.metaKey) { event.preventDefault(); handleSaveFile(); }
                        else if (!event.shiftKey) { setCurrentTool('select'); } 
                        else { dpadAction = false; } 
                        break;
                    case 'a': if (!event.ctrlKey && !event.metaKey && !event.altKey) setCurrentTool('add'); else dpadAction = false; break;
                    case 'm': setCurrentTool('move'); break;
                    case 'd': 
                        if (event.shiftKey) { setCurrentTool('duplicate'); } 
                        else { dpadAction = false; } 
                        break; 
                    case 'r': setCurrentTool('rotate'); break;
                    case 'delete':
                    case 'backspace':
                        if (selectedObject) deleteObject(selectedObject);
                        else setCurrentTool('delete'); 
                        break;
                    case 'enter':
                        if ((currentTool === 'add' && ghostElement && ghostElement.visible && isGhostFixed) || 
                            ((currentTool === 'move' || currentTool === 'rotate') && selectedObject)) {
                            confirmPlacement();
                        }
                        break;
                    case 'escape':
                        if (currentActiveColor !== null) {
                            if (activeSwatchElement) activeSwatchElement.classList.remove('active-color-swatch');
                            currentActiveColor = null;
                            activeSwatchElement = null;
                            updateCursorStyle();
                            updateHelpBar();
                            event.preventDefault(); // Consume the event
                        } else if (currentTool === 'add' && ghostElement) {
                            if (isGhostFixed) {
                                isGhostFixed = false; 
                                if (ghostElement) ghostElement.visible = true; 
                                controls.enabled = false; 
                                controls.enableRotate = false; 
                                updateHelpBar();
                            } else {
                                removeGhostElement(); 
                                setCurrentTool('select'); 
                            }
                        } else if (selectedObject) {
                            deselectObject();
                        }
                        break;

                    case 'w': case 'arrowup': moveGhostOrSelected('forward', event); break;
                    case 'x': case 'arrowdown': moveGhostOrSelected('backward', event); break; 
                    case 'j': case 'arrowleft': moveGhostOrSelected('left', event); break;
                    case 'l': case 'arrowright': moveGhostOrSelected('right', event); break;

                    case 'q': rotateGhostOrSelected('left', event); break;
                    case 'e': rotateGhostOrSelected('right', event); break;
                    case 'pageup': moveGhostOrSelected('up', event); break;
                    case 'pagedown': moveGhostOrSelected('down', event); break;

                    case 'o': 
                        if (event.ctrlKey || event.metaKey) { event.preventDefault(); handleOpenFile(); }
                        else { dpadAction = false; }
                        break;
                    default: dpadAction = false; break;
                }
                if (dpadAction) event.preventDefault(); 
            }

            // --- ACTIONS (Duplicate, Delete) ---
            function duplicateObject(objectToDuplicate) {
                const sourceObject = objectToDuplicate || selectedObject; 
                if (!sourceObject) {
                     return;
                }

                const props = sourceObject.userData;
                const offset = new THREE.Vector3(props.width * 1.05, 0, 0); 
                const newPosition = sourceObject.position.clone().add(offset);
                
                const originalSeatingIndex = currentSeatingIndex;
                currentSeatingIndex = sourceObject.userData.seatingIndex !== undefined ? sourceObject.userData.seatingIndex : currentSeatingIndex;
                const snappedNewPos = getSnappedPosition(newPosition, props); 
                currentSeatingIndex = originalSeatingIndex; 

                const newElement = addElementAtPosition(snappedNewPos, sourceObject.rotation.y, props);
                deselectObject(); 
                selectObject(newElement); 
                setCurrentTool('move'); 
            }

            function deleteObject(objectToDelete) {
                const target = objectToDelete || selectedObject; 
                if (!target || target === plane || target === ghostElement) {
                    return;
                }

                target.traverse((child) => {
                    if (child.isLineSegments && child.name === "elementEdges") {
                        if (child.geometry) child.geometry.dispose();
                        if (child.material) {
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => m.dispose());
                            } else {
                                child.material.dispose();
                            }
                        }
                    }
                });

                scene.remove(target);
                const index = objects.indexOf(target);
                if (index > -1) {
                    objects.splice(index, 1);
                }
                if (target.geometry) target.geometry.dispose();
                if (target.material) {
                    if (Array.isArray(target.material)) {
                        target.material.forEach(m => m.dispose());
                    } else {
                        target.material.dispose();
                    }
                }
                if (selectedObject === target) { 
                    deselectObject(); 
                }
                updateElementCounter();
            }

            // --- SEATING MANAGEMENT ---
            function createNewSeatingLevel() {
                const newIndex = Object.keys(seatingLevels).length > 0 ? Math.max(...Object.keys(seatingLevels).map(Number)) + 1 : 0;
                let newY = 0;
                let highestPoint = -Infinity;
                let hasObjects = objects.length > 0;

                if (hasObjects) {
                    objects.forEach(obj => {
                        const topOfObject = obj.position.y + obj.userData.height / 2;
                        if (topOfObject > highestPoint) {
                            highestPoint = topOfObject;
                        }
                    });
                    newY = snapToGrid(highestPoint);
                     if (Object.keys(seatingLevels).length > 0) {
                        const lastSeatingKey = Object.keys(seatingLevels).sort((a,b) => seatingLevels[a].y - seatingLevels[b].y).pop();
                        if (newY <= seatingLevels[lastSeatingKey].y) {
                            newY = seatingLevels[lastSeatingKey].y + defaultSeatingHeightIncrement;
                        }
                    } else { 
                         newY = snapToGrid(highestPoint > 0 ? highestPoint : defaultSeatingHeightIncrement);
                    }
                } else if (Object.keys(seatingLevels).length > 0) {
                    const lastSeatingKey = Object.keys(seatingLevels).sort((a,b) => seatingLevels[a].y - seatingLevels[b].y).pop();
                    newY = seatingLevels[lastSeatingKey].y + defaultSeatingHeightIncrement;
                } else { 
                    newY = defaultSeatingHeightIncrement; 
                }
                newY = snapToGrid(newY); 

                const newName = `Assise ${newIndex} (Niveau ${newY.toFixed(2)}m)`;
                seatingLevels[newIndex] = { y: newY, name: newName };

                updateSeatingSelector();
                currentSeatingIndex = newIndex; 
                seatingLevelSelector.value = newIndex; 

                if (currentTool === 'add' && ghostElement) {
                    ghostElement.position.y = newY + ghostElement.userData.height / 2;
                }
            }
            function removeCurrentSeatingLevel() {
                const levelToRemove = parseInt(seatingLevelSelector.value); 
                const numLevels = Object.keys(seatingLevels).length;

                if (levelToRemove === 0 && numLevels === 1) {
                    alert("Impossible de supprimer la première assise (Assise 0).");
                    return;
                }
                
                const objectsOnThisLevel = objects.filter(obj => obj.userData.seatingIndex === levelToRemove);
                if (objectsOnThisLevel.length > 0) {
                    alert("Impossible de supprimer une assise qui contient des éléments. Supprimez d'abord les éléments de cette assise.");
                    return;
                }

                let isHighest = true;
                const levelYToRemove = seatingLevels[levelToRemove].y;
                for (const key in seatingLevels) {
                    if (seatingLevels[key].y > levelYToRemove) {
                        isHighest = false;
                        break;
                    }
                }

                if (!isHighest && numLevels > 1 && levelToRemove !==0) { 
                     alert("Pour l'instant, seule la dernière assise (la plus haute) vide peut être supprimée, ou l'assise 0 si elle est vide et qu'il en existe d'autres.");
                     return;
                 }

                delete seatingLevels[levelToRemove];
                
                const remainingIndices = Object.keys(seatingLevels).map(Number).sort((a,b) => seatingLevels[a].y - seatingLevels[b].y);
                if (remainingIndices.length === 0) { 
                    seatingLevels[0] = { y: 0, name: "Assise 0 (Niveau 0.00m)" }; 
                    currentSeatingIndex = 0;
                } else {
                    let newSelection = -1;
                    for (let i = remainingIndices.length - 1; i >= 0; i--) {
                        if (seatingLevels[remainingIndices[i]].y < levelYToRemove) {
                            newSelection = remainingIndices[i];
                            break;
                        }
                    }
                    if (newSelection === -1) { 
                        newSelection = remainingIndices[0];
                    }
                    currentSeatingIndex = newSelection;
                }

                updateSeatingSelector();
                seatingLevelSelector.value = currentSeatingIndex;
            }


            function updateSeatingSelector() {
                seatingLevelSelector.innerHTML = '';
                const sortedKeys = Object.keys(seatingLevels).sort((a,b) => seatingLevels[a].y - seatingLevels[b].y);
                
                sortedKeys.forEach(key => { 
                    const option = document.createElement('option');
                    option.value = key; 
                    option.textContent = seatingLevels[key].name;
                    option.dataset.y = seatingLevels[key].y;
                    seatingLevelSelector.appendChild(option);
                });
                if (seatingLevels[currentSeatingIndex]) {
                    seatingLevelSelector.value = currentSeatingIndex;
                } else if (sortedKeys.length > 0) {
                    currentSeatingIndex = parseInt(sortedKeys[0]); 
                    seatingLevelSelector.value = currentSeatingIndex;
                }
            }

            // --- ELEMENT COUNTER ---
            function updateElementCounter() {
                const counts = {};
                objects.forEach(obj => {
                    const name = obj.userData.name || 'Inconnu';
                    counts[name] = (counts[name] || 0) + 1;
                });

                elementCounterTableBody.innerHTML = '';
                for (const name in counts) {
                    const row = elementCounterTableBody.insertRow();
                    row.insertCell().textContent = name;
                    row.insertCell().textContent = counts[name];
                }
            }

            // --- MENU FUNCTIONS (File, Style, Edit) ---
            function handleNewFile() {
                if (!confirm("Créer un nouveau fichier ? Les modifications non sauvegardées seront perdues.")) return;
                objects.slice().forEach(obj => deleteObject(obj)); 
                objects = []; 

                seatingLevels = { 0: { y: 0, name: "Assise 0 (Niveau 0.00m)" } };
                currentSeatingIndex = 0;
                updateSeatingSelector();
                updateElementCounter(); 
                document.getElementById('project-title').value = '';
                document.getElementById('designer-name').value = '';
                document.getElementById('operating-mode').value = '';
                if (currentTool === 'add') {
                    removeGhostElement(); 
                    createGhostElement(); 
                }
                setCurrentTool('select');
                if (controls) { 
                    camera.position.copy(initialCameraPosition);
                    controls.target.copy(initialCameraLookAt);
                    controls.update();
                }
            }

            function handleOpenFile() {
                const input = document.createElement('input');
                input.type = 'file';
                input.accept = '.json,application/json';
                input.onchange = e => {
                    const file = e.target.files[0];
                    if (!file) return;
                    const reader = new FileReader();
                    reader.onload = event => {
                        try {
                            const data = JSON.parse(event.target.result);
                            loadSceneData(data);
                        } catch (error) {
                            console.error("Erreur de chargement du fichier:", error);
                            alert('Erreur de chargement du fichier : ' + error.message);
                        }
                    };
                    reader.readAsText(file);
                };
                input.click();
            }

            function loadSceneData(data) {
                if (!confirm("Charger ce fichier va remplacer la scène actuelle. Continuer ?")) return;
                
                objects.slice().forEach(obj => deleteObject(obj));
                objects = [];
                seatingLevels = { 0: { y: 0, name: "Assise 0 (Niveau 0.00m)" } }; 
                currentSeatingIndex = 0;
                document.getElementById('project-title').value = '';
                document.getElementById('designer-name').value = '';
                document.getElementById('operating-mode').value = '';

                if (data.metadata) {
                    document.getElementById('project-title').value = data.metadata.projectTitle || '';
                    document.getElementById('designer-name').value = data.metadata.designerName || '';
                    document.getElementById('operating-mode').value = data.metadata.operatingMode || '';
                }

                if (data.seatingLevels && Object.keys(data.seatingLevels).length > 0) {
                    seatingLevels = data.seatingLevels;
                } else {
                    seatingLevels = { 0: { y: 0, name: "Assise 0 (Niveau 0.00m)" } }; 
                }
                currentSeatingIndex = data.currentSeatingIndex !== undefined && seatingLevels[data.currentSeatingIndex] ? data.currentSeatingIndex : 0;
                if (!seatingLevels[currentSeatingIndex] && Object.keys(seatingLevels).length > 0) { 
                    currentSeatingIndex = parseInt(Object.keys(seatingLevels)[0]); 
                }
                updateSeatingSelector(); 

                if (data.styleSettings) {
                    useWhiteElements = data.styleSettings.useWhiteElements || false;
                    shadowsEnabled = data.styleSettings.shadowsEnabled !== undefined ? data.styleSettings.shadowsEnabled : true;
                } else { 
                    useWhiteElements = false;
                    shadowsEnabled = true;
                }
                renderer.shadowMap.enabled = shadowsEnabled;
                scene.traverse(child => {
                    if (child.isLight) child.castShadow = shadowsEnabled;
                });
                toggleShadowsBtn.textContent = shadowsEnabled ? "Désactiver Ombres" : "Activer Ombres";


                if (data.objects) {
                    data.objects.forEach(objData => {
                        const props = {
                            type: objData.type,
                            baseType: objData.baseType,
                            name: objData.name,
                            width: objData.width,
                            height: objData.height,
                            depth: objData.depth,
                        };
                        const position = new THREE.Vector3(objData.position.x, objData.position.y, objData.position.z);
                        const rotationY = objData.rotationY; 
                        
                        const savedSeatingIndex = currentSeatingIndex;
                        currentSeatingIndex = objData.seatingIndex !== undefined && seatingLevels[objData.seatingIndex] ? objData.seatingIndex : 0; 
                        if (!seatingLevels[currentSeatingIndex]) currentSeatingIndex = 0; 

                        const loadedElement = addElementAtPosition(position, rotationY, props);
                        
                        if (objData.originalColor) loadedElement.userData.originalColor = objData.originalColor;

                        if (useWhiteElements) {
                            loadedElement.material.color.set(0xffffff);
                        } else {
                            loadedElement.material.color.set(loadedElement.userData.originalColor || elementColors[props.baseType] || elementColors.default);
                        }
                        loadedElement.castShadow = shadowsEnabled && props.baseType !== 'vide';
                        loadedElement.receiveShadow = shadowsEnabled && props.baseType !== 'vide';
                        
                        currentSeatingIndex = savedSeatingIndex; 
                    });
                }
                updateElementCounter();
                if (currentTool === 'add') { 
                     removeGhostElement(); createGhostElement();
                }
                setCurrentTool('select'); 
                if (seatingLevels[currentSeatingIndex]) { 
                     seatingLevelSelector.value = currentSeatingIndex;
                }
                if (controls) { 
                    camera.position.copy(initialCameraPosition);
                    controls.target.copy(initialCameraLookAt);
                    controls.update();
                }
            }


            function handleSaveFile() {
                const sceneData = {
                    metadata: {
                        projectTitle: document.getElementById('project-title').value,
                        designerName: document.getElementById('designer-name').value,
                        operatingMode: document.getElementById('operating-mode').value,
                    },
                    objects: objects.map(obj => ({
                        type: obj.userData.type,
                        baseType: obj.userData.baseType,
                        name: obj.userData.name,
                        width: obj.userData.width,
                        height: obj.userData.height,
                        depth: obj.userData.depth,
                        position: { x: obj.position.x, y: obj.position.y, z: obj.position.z },
                        rotationY: obj.rotation.y,
                        originalColor: obj.userData.originalColor, 
                        seatingIndex: obj.userData.seatingIndex
                    })),
                    seatingLevels: seatingLevels,
                    currentSeatingIndex: currentSeatingIndex,
                    styleSettings: {
                        useWhiteElements: useWhiteElements,
                        shadowsEnabled: shadowsEnabled
                    }
                };

                const filenameBase = sceneData.metadata.projectTitle || "simulation_mur_3d";
                const filename = filenameBase.replace(/[^a-z0-9]/gi, '_').toLowerCase() + ".json";
                const blob = new Blob([JSON.stringify(sceneData, null, 2)], { type: 'application/json' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = filename;
                document.body.appendChild(link); 
                link.click();
                document.body.removeChild(link);
                URL.revokeObjectURL(link.href);
            }

            async function handleExportPDF() {
                if (typeof jsPDF === 'undefined' && typeof window.jspdf.jsPDF === 'undefined') {
                    alert("La librairie jsPDF n'a pas pu être chargée. L'export PDF est indisponible.");
                    return;
                }
                const { jsPDF: JSPDF_LIB } = window.jspdf; 
                if (!JSPDF_LIB) {
                     alert("Erreur interne avec jsPDF. L'export PDF est indisponible.");
                    return;
                }

                const pdf = new JSPDF_LIB({ orientation: 'landscape', unit: 'mm', format: 'a4' });
                const pdfTitle = document.getElementById('project-title').value || "Simulation de Mur 3D";
                const designer = document.getElementById('designer-name').value || "N/A";
                const date = new Date().toLocaleDateString('fr-FR');

                const originalCameraState = {
                    position: camera.position.clone(),
                    rotation: camera.rotation.clone(), 
                    fov: camera.fov,
                    aspect: camera.aspect,
                    near: camera.near,
                    far: camera.far,
                    zoom: camera.zoom,
                    target: controls.target.clone()
                };
                
                const gridHelperObj = scene.getObjectByName("GridHelper"); 
                const dLightHelper = scene.getObjectByName("DirectionalLightHelper"); 
                const dLightShadowHelper = scene.getObjectByName("CameraHelper"); 
                if (gridHelperObj) gridHelperObj.visible = false;
                if (dLightHelper) dLightHelper.visible = false;
                if (dLightShadowHelper) dLightShadowHelper.visible = false;
                
                const ghostWasVisible = ghostElement ? ghostElement.visible : false;
                if (ghostElement) ghostElement.visible = false;
                
                const previouslySelected = selectedObject; 
                deselectObject(); 

                renderer.setPixelRatio(2); 

                const views = [ 
                    { name: "Perspective", pos: [6, 4, 6], target: [0, 0.5, 0], isPerspective: true },
                    { name: "Face (Avant Z+)", pos: [0, 1.5, 8], target: [0, 1, 0], isPerspective: false },
                    { name: "Arrière (Z-)", pos: [0, 1.5, -8], target: [0, 1, 0], isPerspective: false },
                    { name: "Gauche (X-)", pos: [-8, 1.5, 0], target: [0, 1, 0], isPerspective: false },
                    { name: "Droite (X+)", pos: [8, 1.5, 0], target: [0, 1, 0], isPerspective: false },
                    { name: "Dessus (Y+)", pos: [0, 8, 0.01], target: [0, 0, 0], isPerspective: false },
                ];

                const margin = 10; 
                const pageWidth = pdf.internal.pageSize.getWidth();
                const pageHeight = pdf.internal.pageSize.getHeight();
                const headerHeight = 30; 
                const availableWidth = pageWidth - 2 * margin;
                const availableHeight = pageHeight - headerHeight - 2 * margin;
                
                const imgWidth = (availableWidth - margin) / 2; 
                const imgHeight = availableHeight * 0.75; 

                let viewCount = 0;
                for (let i = 0; i < views.length; i++) {
                    if (viewCount % 2 === 0 && viewCount > 0) { 
                        pdf.addPage();
                    }
                    if (viewCount % 2 === 0) { 
                        pdf.setFontSize(16);
                        pdf.text(pdfTitle, margin, margin + 5);
                        pdf.setFontSize(10);
                        pdf.text(`Dessinateur: ${designer}`, margin, margin + 12);
                        pdf.text(`Date: ${date}`, margin, margin + 17);
                        pdf.text(`Page ${Math.floor(viewCount / 2) + 1}`, pageWidth - margin -15, margin + 5);
                        pdf.text("SimulateurDeMur3D", pageWidth - margin, pageHeight - 5, { align: 'right' });
                    }

                    const view = views[i];
                    camera.position.set(view.pos[0], view.pos[1], view.pos[2]);
                    controls.target.set(view.target[0], view.target[1], view.target[2]);
                    
                    if (!view.isPerspective) {
                        const distance = camera.position.distanceTo(controls.target);
                        const desiredVisibleHeight = 5; 
                        camera.fov = 2 * Math.atan( (desiredVisibleHeight / 2) / distance ) * (180 / Math.PI);
                        camera.fov = Math.max(5, Math.min(camera.fov, 30)); 
                    } else {
                        camera.fov = originalCameraState.fov; 
                    }
                    camera.updateProjectionMatrix();
                    controls.update(); 

                    renderer.render(scene, camera);
                    const imgData = renderer.domElement.toDataURL('image/png');

                    const xPos = margin + (viewCount % 2) * (imgWidth + margin);
                    const yPos = headerHeight;

                    pdf.setFontSize(9);
                    pdf.text(view.name, xPos, yPos + 5);
                    pdf.addImage(imgData, 'PNG', xPos, yPos + 8, imgWidth, imgHeight);
                    viewCount++;
                }

                camera.position.copy(originalCameraState.position);
                camera.rotation.copy(originalCameraState.rotation);
                camera.fov = originalCameraState.fov;
                camera.aspect = originalCameraState.aspect;
                camera.near = originalCameraState.near;
                camera.far = originalCameraState.far;
                camera.zoom = originalCameraState.zoom;
                controls.target.copy(originalCameraState.target);
                camera.updateProjectionMatrix();
                controls.update();

                if (gridHelperObj) gridHelperObj.visible = true;
                if (dLightHelper) dLightHelper.visible = true;
                if (dLightShadowHelper) dLightShadowHelper.visible = true;
                if (ghostElement && ghostWasVisible) ghostElement.visible = true;
                if (previouslySelected) selectObject(previouslySelected); 

                renderer.setPixelRatio(window.devicePixelRatio); 

                pdf.save(pdfTitle.replace(/[^a-z0-9]/gi, '_').toLowerCase() + "_vues.pdf");
            }


            function handleEditSelection() {
                if (!selectedObject) {
                    alert("Aucun élément sélectionné à modifier.");
                    return;
                }
                
                elementTypeSelector.value = selectedObject.userData.type;
                elementTypeSelector.dispatchEvent(new Event('change')); 

                if (selectedObject.userData.type === 'custom') {
                    customNameInput.value = selectedObject.userData.name;
                    customWidthInput.value = selectedObject.userData.width;
                    customHeightInput.value = selectedObject.userData.height;
                    customDepthInput.value = selectedObject.userData.depth;
                } else if (selectedObject.userData.type === 'vide') {
                    videDepthInput.value = selectedObject.userData.depth * 100; 
                }

                const oldPosition = selectedObject.position.clone();
                const oldRotationY = selectedObject.rotation.y;
                const oldSeatingIndex = selectedObject.userData.seatingIndex;
                deleteObject(selectedObject); 

                setCurrentTool('add'); 
                if (ghostElement) {
                    const newProps = getElementProperties(); 
                    ghostElement.geometry.dispose();
                    ghostElement.geometry = new THREE.BoxGeometry(newProps.width, newProps.height, newProps.depth);
                    ghostElement.userData = {...newProps, isGhost: true};

                    ghostElement.position.copy(oldPosition);
                    ghostElement.rotation.y = oldRotationY;
                    
                    currentSeatingIndex = oldSeatingIndex; 
                    seatingLevelSelector.value = currentSeatingIndex; 
                    const currentLevelY = seatingLevels[currentSeatingIndex] ? seatingLevels[currentSeatingIndex].y : 0;
                    ghostElement.position.y = currentLevelY + newProps.height / 2; 
                    
                    ghostElement.visible = true;
                    isGhostFixed = true; 
                }
                alert("Modifiez les propriétés dans la barre d'outils si nécessaire, puis ajustez la position avec le DPad et confirmez avec 'OK' ou 'Entrée'.");
            }


            function setElementStyle(isWhite) {
                useWhiteElements = isWhite;
                objects.forEach(obj => {
                    if (obj.material && obj.userData.originalColor) { 
                        obj.material.color.set(useWhiteElements ? 0xffffff : obj.userData.originalColor);
                        obj.material.needsUpdate = true;
                    }
                });
            }

            function toggleAllShadows() {
                shadowsEnabled = !shadowsEnabled;
                renderer.shadowMap.enabled = shadowsEnabled;

                scene.traverse(child => {
                    if (child.isLight && child.castShadow !== undefined) {
                        child.castShadow = shadowsEnabled;
                    }
                    if (child.isMesh && child !== plane && child !== ghostElement) {
                        child.castShadow = shadowsEnabled && child.userData.baseType !== 'vide';
                        child.receiveShadow = shadowsEnabled && child.userData.baseType !== 'vide';
                        if (child.material) child.material.needsUpdate = true; 
                    }
                });
                if (plane.material) plane.material.needsUpdate = true;
                toggleShadowsBtn.textContent = shadowsEnabled ? "Désactiver Ombres" : "Activer Ombres";
            }

            // --- ANIMATION LOOP ---
            function animate() {
                requestAnimationFrame(animate);
                controls.update(); 
                renderer.render(scene, camera);
            }

            // --- START APPLICATION ---
            initThreeJS();
            console.log("Simulateur de murs initialisé. Version avec débogage v5 (correctif isGhost et DPad).");
        });
    </script>
</body>
</html>
